[{"content":"一、元数据metadata 元数据是指用来描述数据的数据，更通俗一点，就是描述代码间关系，或者代码与其他资源（例如数据库表）之间内在联系的数据。\n基于元数据的广泛应用，JDK5.0 引入了 Annotation 的概念来描述元数据。在 Java 中，元数据以标签的形式存在于 Java 代码中，元数据标签的存在并不影响程序代码的编译和执行。\nJava语言中有四种类型（TYPE），即类（class）、枚举（enum）、接口（interface）和注解（@interface），它们是处在同一级别的。Java 就是通过注解来表示元数据的。\n二、注解 注解相当于是一种嵌入在程序中的元数据，可以使用注解解析工具或编译器对其进行解析，也可以指定注解在编译期或运行期有效。\n如果说注释是写给人看的，那么注解就是写给程序看的。它更像一个标签，贴在一个类、一个方法或者字段上。它的目的是为当前读取该注解的程序提供判断依据及少量附加信息。比如程序只要读到加了@Test 的方法，就知道该方法是待测试方法，又比如 @Before 注解，程序看到这个注解，就知道该方法要放在 @Test 方法之前执行。有时我们还可以通过注解属性，为将来读取这个注解的程序提供必要的附加信息，比如 @RequestMapping(\u0026quot;/user/info\u0026quot;) 提供了 Controller 某个接口的 URL 路径。\n注解三要素：定义、使用、读取并执行\nAnnotation 就是 Java 提供的一种元程序中的元素关联任何信息和任何元数据的途径。Annotation 是一个接口，程序可以通过反射来获取指定程序元素的 Annotation 对象，然后通过 Annotation 对象来获取注解里面的元数据。\njava.lang.annotation.Annotation 本身是接口，而不是注解，当使用关键字 @interface 定义一个注解时，该注解隐式地继承了 java.lang.annotation.Annotation 接口；如果我们定义一个接口，并且让该接口继承自 Annotation，那么我们定义的接口依然是接口而不是注解。综上，定义注解只能依靠 @interface 实现。\n注解分类 按照注解使用方法和用途分为 JDK 内置注解、第三方注解和自定义注解\n按照注解参数个数分为\n标记注解：没有成员变量的 Annotation 类型称为标记注解 单值注解：只有一个值 完整注解：拥有多个值 JDK内置注解 @Override：检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated： 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings：该注解的作用是阻止编译器发出某些警告信息。它可以有以下参数： @SuppressWarnings(\u0026#34;deprecation\u0026#34;)\t// 过时的类或方法警告 @SuppressWarnings(\u0026#34;unchecked\u0026#34;)\t// 执行了未检查的转换时警告 @SuppressWarnings(\u0026#34;fallthrough\u0026#34;)\t// 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告 @SuppressWarnings(\u0026#34;path\u0026#34;)\t// 在类路径、源文件路径等中有不存在的路径时的警告 @SuppressWarnings(\u0026#34;serial\u0026#34;)\t// 当在可序列化的类上缺少 serialVersionUID 定义时的警告 @SuppressWarnings(\u0026#34;finally\u0026#34;)\t// 任何 finally 子句不能完成时的警告 @SuppressWarnings(\u0026#34;all\u0026#34;)\t// 关于以上所有情况的警告 @Inherited：标记这个注解是继承于哪个注解类（默认注解并没有继承于任何子类） @SafeVarargs： 忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface：标识一个匿名函数或函数式接口。 @Repeatable：标识某注解可以在同一个声明上使用多次。 元注解 所谓元注解，就是加在注解上的注解。\n@Documented：标记这些注解是否包含在用户文档中。\n@Target：它是被定义在一个注解类的前面，用来说明该注解可以被声明在哪些元素前。(默认可以放在任何元素之前)。它有以下参数：\nElementType.TYPE\t// 说明该注解只能被声明在一个类、接口、枚举前。 ElementType.FIELD\t// 说明该注解只能被声明在一个类的字段前。 ElementType.METHOD\t// 说明该注解只能被声明在一个类的方法前。 ElementType.PARAMETER\t// 说明该注解只能被声明在一个方法参数前。 ElementType.CONSTRUCTOR\t// 说明该注解只能声明在一个类的构造方法前。 ElementType.LOCAL_VARIABLE\t// 说明该注解只能声明在一个局部变量前。　ElementType.ANNOTATION_TYPE\t// 说明该注解只能声明在一个注解类型前。 ElementType.PACKAGE\t// 说明该注解只能声明在一个包名前。 // 例如：此注解只能用在方法上 @Target(ElementType.METHOD) @interface TestMethod {} @Retention（注解的保留策略） 表示需要在什么级别保存该注释信息，用于描述注解的生命周期，即被描述的注解在什么范围内有效，表示注解类型保留时间的长短。\npublic @interface Retention { RetentionPolicy value(); } 有三个备选值：SOURCE、ClASS、RUNTIME，保留时长递增\nSOURCE：指定注解只保留在源文件当中。 CLASS：指定注解只保留在 class 文件中。（缺省） RUNTIME：指定注解可以保留在程序运行期间。 // 此注解可以用于注解类、接口(包括注解类型) 或 enum 声明 @Target(ElementType.TYPE) // 该注解运行时有效。注解处理器可以通过反射获取到该注解的属性值，从而去做一些运行时的逻辑处理 @Retention(RetentionPolicy.RUNTIME) @interface TestRn {} @Inherited 表明该注解将会被子类继承。加上该元注解的注解，只有用在类元素上才有效果。\n// 被子类继承的注解 @Inherited @interface TestInheri{} 自定义注解 @interface 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum以及它们的数组）。可以通过 default 来声明参数的默认值。\n如果只有一个属性/方法且叫 value，那么使用该注解时可以不指定属性名，因为默认给 value 赋值，注解的属性如果有多个，无论是否叫 value，都必须写明属性的对应关系。\n注解里面的每一个方法实际上就是声明了一个配置参数，其规则如下：\n只能用 public 或 default 这两个访问权修饰 ，默认为 default\n注解参数只支持以下数据类型：基本数据类型、String 类型、Class类型、Enum 类型、Annotation 类型、以上类型的一维数组\n注解中的方法不能存在参数，可以包含默认值，使用 default 来声明默认值。\n如果数组的元素只有一个，可以省略花括号 {}：\n如果希望为注解的属性提供统一的几个可选值，可以使用常量类（另外定义静态类或者在注解内部定义静态类）\n在程序中获取注解 // 返回指定注解，参数为注解类文件 \u0026lt;A extends Annotation\u0026gt; A getAnnotation(Class\u0026lt;A\u0026gt; annotationClass); // 按从上到下的顺序返回所有注解 Annotation[] getAnnotations(); ","permalink":"https://note-site.pages.dev/posts/java/java-%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/","summary":"\u003ch2 id=\"一元数据metadata\"\u003e一、元数据metadata\u003c/h2\u003e\n\u003cp\u003e元数据是指用来描述数据的数据，更通俗一点，就是描述代码间关系，或者代码与其他资源（例如数据库表）之间内在联系的数据。\u003c/p\u003e\n\u003cp\u003e基于元数据的广泛应用，JDK5.0 引入了 \u003ccode\u003eAnnotation\u003c/code\u003e 的概念来描述元数据。在 Java 中，元数据以标签的形式存在于 Java 代码中，元数据标签的存在并不影响程序代码的编译和执行。\u003c/p\u003e","title":"Java 中的注解"},{"content":" 中文名称 英文名称 用途 支持 输入法冲突修复 IMBlocker 修复中文输入法冲突 Fabric、Forge、NeoForge Nyf 的箭袋 Nyf\u0026rsquo;s Quivers 添加箭袋 Fabric、Forge Freecam 开源版本，灵魂出窍 Fabric、Forge、NeoForge Cloth Config API 通用拼音搜索 Just Enough Characters 支持拼音搜索物品 苹果皮 AppleSkin 饱食度可视化，显示食物饱食度 自动汉化更新 I18nUpdateMod JEI 物品管理器 Just Enough Items 祛魔编辑台 Disenchantment Edit Table 分离装备或附魔书上的附魔 鞘翅插槽 Elytra Slot 添加鞘翅插槽，可以同时装备盔甲 ","permalink":"https://note-site.pages.dev/posts/games/minecraft-%E6%A8%A1%E7%BB%84%E6%8E%A8%E8%8D%90/","summary":"\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e中文名称\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e英文名称\u003c/th\u003e\n          \u003cth\u003e用途\u003c/th\u003e\n          \u003cth\u003e支持\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e输入法冲突修复\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ca href=\"https://www.mcmod.cn/class/3358.html\"\u003eIMBlocker\u003c/a\u003e\u003c/td\u003e\n          \u003ctd\u003e修复中文输入法冲突\u003c/td\u003e\n          \u003ctd\u003eFabric、Forge、NeoForge\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eNyf 的箭袋\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ca href=\"https://www.mcmod.cn/class/6031.html\"\u003eNyf\u0026rsquo;s Quivers\u003c/a\u003e\u003c/td\u003e\n          \u003ctd\u003e添加箭袋\u003c/td\u003e\n          \u003ctd\u003eFabric、Forge\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003ca href=\"https://www.mcmod.cn/class/8979.html\"\u003eFreecam\u003c/a\u003e\u003c/td\u003e\n          \u003ctd\u003e开源版本，灵魂出窍\u003c/td\u003e\n          \u003ctd\u003eFabric、Forge、NeoForge\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eCloth Config API\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e通用拼音搜索\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eJust Enough Characters\u003c/td\u003e\n          \u003ctd\u003e支持拼音搜索物品\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e苹果皮\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eAppleSkin\u003c/td\u003e\n          \u003ctd\u003e饱食度可视化，显示食物饱食度\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e自动汉化更新\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eI18nUpdateMod\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eJEI 物品管理器\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eJust Enough Items\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e祛魔编辑台\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eDisenchantment Edit Table\u003c/td\u003e\n          \u003ctd\u003e分离装备或附魔书上的附魔\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e鞘翅插槽\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003eElytra Slot\u003c/td\u003e\n          \u003ctd\u003e添加鞘翅插槽，可以同时装备盔甲\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e","title":"MineCraft 模组推荐"},{"content":"IDEA配置 Appearance \u0026amp; Behavior: Appearance: Use Custom Font: Inter Size: 13 Editor: Font: Font: JetBrains Mono Size: 13 Line Height: 1.2 ","permalink":"https://note-site.pages.dev/posts/miscellaneous/%E9%85%8D%E7%BD%AE%E6%B1%87%E6%80%BB/","summary":"\u003ch2 id=\"idea配置\"\u003eIDEA配置\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-yaml\" data-lang=\"yaml\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nt\"\u003eAppearance \u0026amp; Behavior\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003eAppearance\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eUse Custom Font\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eInter\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eSize\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"m\"\u003e13\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"nt\"\u003eEditor\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"nt\"\u003eFont\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eFont\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"l\"\u003eJetBrains Mono\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eSize\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"m\"\u003e13\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"nt\"\u003eLine Height\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"m\"\u003e1.2\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"配置汇总"},{"content":"介绍 官网： https://www.sublimetext.com\n下载地址 https://download.sublimetext.com/sublime_text_build_4180_x64_setup.exe\n激活 安装之后，使用sublime text 打开安装目录下的sublime_text.exe文件。\nCtrl + F 搜索\n8079 0500 0f94 c2 更改为\nc641 0501 b200 90 另存到其他路径，然后关闭 sublime text，替换原 sublime_text.exe 即可。\n检查激活状态 点击菜单栏 Help - About Sublime Text 可检测激活状态。\n软件安装中文语言包 1、点击菜单栏 Tools - Install Package Control 跳出弹框点击确定按钮\n2、点击菜单栏 Preferences – Package Control\n3、弹框中输入 Install package，选中 Package Control: Install Package 然后等待弹窗（可能需要耐心等待一段时间）\n4、等出现如下弹窗后, 在弹窗的搜索框中输入 ChineseLocalizations，点击出现的选项\n5、等待一段时间，如果出现了如下画面则汉化步骤全部完成\n6、后续若需要更改，可点击菜单栏 帮助 - Language 选择进行更改。\n声明 转载自 https://songxwn.com/Sublime_Text4_4180/\n","permalink":"https://note-site.pages.dev/posts/miscellaneous/sublime-text-4-build-4180-%E6%BF%80%E6%B4%BB/","summary":"\u003ch2 id=\"介绍\"\u003e介绍\u003c/h2\u003e\n\u003cp\u003e官网： \u003ca href=\"https://www.sublimetext.com/\"\u003ehttps://www.sublimetext.com\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"下载地址\"\u003e下载地址\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://download.sublimetext.com/sublime_text_build_4180_x64_setup.exe\"\u003ehttps://download.sublimetext.com/sublime_text_build_4180_x64_setup.exe\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"激活\"\u003e激活\u003c/h2\u003e\n\u003cp\u003e安装之后，使用sublime text 打开安装目录下的sublime_text.exe文件。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eCtrl + F\u003c/code\u003e 搜索\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e8079 0500 0f94 c2\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e更改为\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ec641 0501 b200 90\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/posts/miscellaneous/sublime-text-4-build-4180-%E6%BF%80%E6%B4%BB/assets/1.webp\"\u003e\u003c/p\u003e\n\u003cp\u003e另存到其他路径，然后关闭 sublime text，替换原 sublime_text.exe 即可。\u003c/p\u003e","title":"Sublime Text 4 Build 4180 激活"},{"content":"Telegram 被封禁解封方法一 用手机或者电脑浏览器打开链接 https://telegram.org/support 这个网页是 Telegram 官方支持页面。\nPlease describe your problem 内容填写如下，自行编辑也可以。 Dear Sir/Ma’am. My number +1 xxx xxx xxxx been banned and i am not able to figure out the reason for supension, please help me to recover my account. Thank you. Your email 内容填写 随便填写一个 Your phone number 内容填写 你的 Telegram 登录手机号码 Telegram 被封禁解封方法二 使用自己任意一个邮箱，编辑邮件发送至\n① login@stel.com\n② recover@telegram.org\n③ login@telegram.org ，邮件内容如下\n邮件标题 Banned phone number: +1 xxx xxx xxxx 邮件内容 I’m trying to use my mobile phone number: +1 xxx xxx xxxx But Telegram says it’s banned. Please help. I need this account it’s on my most used number. App version: 8.7.4 (26367) OS version: SDK 30 Device Name: Android Thank you. 邮件中 +1 xxx xxx xxxx 是您 Telegram 登入手机号，+1 是指国家号，中国是 +86，千万别弄错了。邮件寄出后大概 1~7 天 Telegram 就可以正常登录了，前提是您封号的原因不是严重违规。Telegram 官方客服人员非常少，所以三个邮箱多多不间断轰炸。\nTelegram 被封禁解封方法三 打开 Telegram 官方推特 https://x.com/smstelegram ，私聊发送方法 1 或方法 2 邮件内容。\n最好是有推特的会员，这样私信是无法被忽视的。我之前 spotify 被封就是这样得到官方的回复。\n","permalink":"https://note-site.pages.dev/posts/miscellaneous/telegram%E8%A2%AB%E5%B0%81%E5%8F%B7%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","summary":"\u003ch3 id=\"telegram-被封禁解封方法一\"\u003eTelegram 被封禁解封方法一\u003c/h3\u003e\n\u003cp\u003e用手机或者电脑浏览器打开链接 \u003ca href=\"https://telegram.org/support\"\u003ehttps://telegram.org/support\u003c/a\u003e 这个网页是 Telegram 官方支持页面。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ePlease describe your problem 内容填写如下，自行编辑也可以。 \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eDear Sir/Ma’am. \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eMy number +1 xxx xxx xxxx been banned and i am not able to figure out the reason for supension,\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eplease help me to recover my account. Thank you. \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eYour email 内容填写 随便填写一个 \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eYour phone number 内容填写 你的 Telegram 登录手机号码\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"telegram-被封禁解封方法二\"\u003eTelegram 被封禁解封方法二\u003c/h3\u003e\n\u003cp\u003e使用自己任意一个邮箱，编辑邮件发送至\u003c/p\u003e","title":"Telegram被封号解决办法"},{"content":"从二叉堆的结构说起，它是一棵二叉树，并且是完全二叉树，每个结点中存有一个元素（或者说，有个权值）。\n堆性质：父亲的权值不小于儿子的权值（大根堆）。同样的，我们可以定义小根堆。本文以大根堆为例。\n实现 一般实现 public class Heap3 { int[] h; int n; public Heap3(int[] nums) { h = nums; n = nums.length; for (int i = n - 2; i \u0026gt;= 0; i--) { sink(i); } } public void sink(int x) { while (x * 2 + 1 \u0026lt; n) { int c = x * 2 + 1; if (c + 1 \u0026lt; n \u0026amp;\u0026amp; h[c + 1] \u0026gt; h[c]) { c++; } if (h[x] \u0026gt;= h[c]) return; swap(x, c); x = c; } } public void rise(int x) { while (x \u0026gt; 0 \u0026amp;\u0026amp; h[x - 1 \u0026gt;\u0026gt; 1] \u0026lt; h[x]) { swap(x, x - 1 \u0026gt;\u0026gt; 1); x = x - 1 \u0026gt;\u0026gt; 1; } } public void swap(int x, int y) { int t = h[x]; h[x] = h[y]; h[y] = t; } } 带泛型实现 /** * 默认大根堆 * @param \u0026lt;T\u0026gt; */ public class Heap2\u0026lt;T extends Comparable\u0026lt;T\u0026gt;\u0026gt; { private int n; private final T[] h; private final Comparator\u0026lt;? super T\u0026gt; comp; public Heap2(T[] h) { this.h = h; this.comp = Comparable::compareTo; this.n = h.length; heapify(); } public Heap2(T[] h, Comparator\u0026lt;? super T\u0026gt; comp) { this.h = h; this.comp = comp; this.n = h.length; heapify(); } private void heapify() { heapify(0, n); } /** * 在 [l,r) 之间堆化 * @param l 左边界 * @param r 右边界 */ private void heapify(int l, int r) { for (int i = r - 2; i \u0026gt;= l; i--) { sink(i, r); } } private void sink(int x) { sink(x, n); } private void sink(int x, int r) { while (x * 2 + 1 \u0026lt; r) { int c = x * 2 + 1; if (c + 1 \u0026lt; r \u0026amp;\u0026amp; comp.compare(h[c + 1], h[c]) \u0026gt; 0) { c++; } if (comp.compare(h[c], h[x]) \u0026lt;= 0) return; swap(x, c); x = c; } } private void rise(int x) { while (x \u0026gt; 0 \u0026amp;\u0026amp; comp.compare(h[x - 1 \u0026gt;\u0026gt; 1], h[x]) \u0026lt; 0) { swap(x, x - 1 \u0026gt;\u0026gt; 1); x = x - 1 \u0026gt;\u0026gt; 1; } } public void updateFirst(T newData) { update(h[0], newData); } public void update(T oldData, T newData) { for (int i = 0; i \u0026lt; n; i++) { if (h[i].equals(oldData)) { h[i] = newData; if (comp.compare(newData, oldData) \u0026gt; 0) rise(i); else sink(i); return; } } } public T poll() { swap(0, --n); sink(0); return h[n]; } public boolean isEmpty() { return h == null || n == 0; } private void swap(int i, int j) { if (i \u0026lt; 0 || j \u0026lt; 0) return; T tmp = h[i]; h[i] = h[j]; h[j] = tmp; } // 按大小顺序输出 @Override public String toString() { StringBuilder builder = new StringBuilder(); builder.append(\u0026#34;[\u0026#34;); int k = n; while (!isEmpty()) { builder.append(poll()).append(\u0026#34;, \u0026#34;); } n = k; heapify(); builder.delete(builder.length() - 2, builder.length()); builder.append(\u0026#34;]\u0026#34;); return builder.toString(); } // 按堆数组顺序输出 public String toString2() { StringBuilder builder = new StringBuilder(); builder.append(\u0026#34;[\u0026#34;); for (int i = 0; i \u0026lt; n - 1; i++) { builder.append(h[i]).append(\u0026#34;, \u0026#34;); } builder.append(h[n - 1]).append(\u0026#34;]\u0026#34;); return builder.toString(); } } 参考 [1] 二叉堆 - OI Wiki\n","permalink":"https://note-site.pages.dev/posts/algorithm/%E4%BA%8C%E5%8F%89%E5%A0%86/","summary":"\u003cp\u003e从二叉堆的结构说起，它是一棵二叉树，并且是完全二叉树，每个结点中存有一个元素（或者说，有个权值）。\u003c/p\u003e\n\u003cp\u003e堆性质：父亲的权值不小于儿子的权值（大根堆）。同样的，我们可以定义小根堆。本文以大根堆为例。\u003c/p\u003e","title":"二叉堆"},{"content":"并查集（Disjoint Set Union）是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。\n顾名思义，并查集支持两种操作：\n合并（Union）：合并两个元素所属集合（合并对应的树） 查询（Find）：查询某个元素所属集合（查询对应的树的根节点），这可以用于判断两个元素是否属于同一集合 实现 public class DSU { int[] pa, size; public DSU(int n) { pa = new int[n]; size = new int[n]; for (int i = 0; i \u0026lt; n; i++) { pa[i] = i; } Arrays.fill(size, 1); } public int find(int z) { return pa[z] == z ? z : (pa[z] = find(pa[z])); } public void union(int x, int y) { int fx = find(x), fy = find(y); if (fx == fy) return; int larger = size[fx] \u0026gt;= size[fy] ? fx : fy; int smaller = larger == fx ? fy : fx; pa[smaller] = larger; size[larger] += size[smaller]; } } 时空复杂度 同时使用路径压缩和启发式合并之后，并查集的每个操作平均时间仅为 $O(\\alpha(n))$，其中 $\\alpha$ 为阿克曼函数的反函数，其增长极其缓慢，也就是说其单次操作的平均运行时间可以认为是一个很小的常数。\n空间复杂度：$O(n)$\n例题 [1] LeetCode 547. 省份数量\n[2] LeetCode 2316. 统计无向图中无法互相到达点对数\n参考 [1] 并查集 - OI Wiki\n","permalink":"https://note-site.pages.dev/posts/algorithm/%E5%B9%B6%E6%9F%A5%E9%9B%86/","summary":"\u003cp\u003e并查集（Disjoint Set Union）是一种用于管理元素所属集合的数据结构，实现为一个森林，其中每棵树表示一个集合，树中的节点表示对应集合中的元素。\u003c/p\u003e","title":"并查集"},{"content":" 计算数组中所有数在数轴上两两之间的距离的和 例如：[1,2,4,9]，结果为 (2-1)+(4-1)+(9-1)+(4-2)+(9-2)+(9-4)=26；\n思路：从小到大枚举 $nums[i]$，此时左边有 $i$ 个数字，右边有 $n-i$ 个数字（算上 $nums[i]$），所以共有 $i×(n−i)$ 对数字在计算距离时会累加 $nums[i] - nums[i-1]$。我们依次遍历完 $[1,n-1]$ 范围内所有的 $nums[i]$，将 $(nums[i] - nums[i - 1]) * i * (n - i)$ 累加到答案中即可。\npublic int calc(int[] nums) { int ans = 0; for (int i = 1, n = nums.length; i \u0026lt; n; i++) { ans += (nums[i] - nums[i - 1]) * i * (n - i); } return ans; } 计算数组两两乘积之和 例如：[1,2,4,9]，结果为 1*2 + 1*4 + 1*9 + 2*4 + 2*9 + 4*9 = 77；\n思路：首先计算数组和 sum，每一项对最终结果的贡献就是 nums[i] * (sum - nums[i])，但是每一项最终会被计算两遍，所以需要除以 2。自己想想就能证明。\npublic long calc(int[] nums) { long ans = 0; int sum = Arrays.stream(nums).sum(); for (int num : nums) { ans += (long) num * (sum - num); } return ans \u0026gt;\u0026gt; 1; } ","permalink":"https://note-site.pages.dev/posts/algorithm/%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/","summary":"\u003col\u003e\n\u003cli\u003e计算数组中所有数在数轴上两两之间的距离的和\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e例如：\u003ccode\u003e[1,2,4,9]\u003c/code\u003e，结果为 \u003ccode\u003e(2-1)+(4-1)+(9-1)+(4-2)+(9-2)+(9-4)=26\u003c/code\u003e；\u003c/p\u003e\n\u003cp\u003e思路：从小到大枚举 $nums[i]$，此时左边有 $i$ 个数字，右边有 $n-i$ 个数字（算上 $nums[i]$），所以共有 $i×(n−i)$ 对数字在计算距离时会累加 $nums[i] - nums[i-1]$。我们依次遍历完 $[1,n-1]$ 范围内所有的 $nums[i]$，将 $(nums[i] - nums[i - 1]) * i * (n - i)$ 累加到答案中即可。\u003c/p\u003e","title":"基础问题"},{"content":"快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在 $O(\\log n)$ 的时间内计算 $a^n$ 的小技巧，而暴力的计算需要 $O(n)$ 的时间。\n过程 首先将 $n$ 表示为二进制，例如\n$$ 3^{13}=3^{(1101)_2}=3^8 \\cdot 3^4 \\cdot 3^1 $$ 因为 $n$ 有 $[\\log_2n]+1$ 个二进制位，所以只需要计算 $\\log(n)$ 次乘法就可以计算出 $a^n$ 。\n于是我们只需要知道一个快速的方法来计算上述 3 的 $2^k$ 次幂的序列。这个问题很简单，因为序列中（除第一个）任意一个元素就是其前一个元素的平方。举一个例子：\n$$ \\begin{align} 3^1 \u0026= 3 \\\\ 3^2 \u0026= \\left(3^1\\right)^2 = 3^2 = 9 \\\\ 3^4 \u0026= \\left(3^2\\right)^2 = 9^2 = 81 \\\\ 3^8 \u0026= \\left(3^4\\right)^2 = 81^2 = 6561 \\end{align} $$ 因此为了计算 $3^{13}$，我们只需要将对应二进制位为 1 的整系数幂乘起来就行了：\n$$ 3^{13} = 6561 \\cdot 81 \\cdot 3 = 1594323 $$一般实现 递归实现：\n// a:底数； b:指数 long binpow(long a, long b) { if (b == 0)\treturn 1; long res = binpow(a, b \u0026gt;\u0026gt; 1); if ((b \u0026amp; 1) == 1) return res * res * a; return res * res; } 非递归实现：\n// a:底数； b:指数 long binpow(long a, long b) { long res = 1; while (b \u0026gt; 0) { if ((b \u0026amp; 1) == 1)\tres *= a; a *= a; b \u0026gt;\u0026gt;= 1 } return res; } 模意义下实现 计算 $x^n\\bmod m$ 。\n取模的运算不会干涉乘法运算，因此我们只需要在计算的过程中取模即可。\nlong binpow(long a, long b, long m) { a %= m; long res = 1; while (b \u0026gt; 0) { if ((b \u0026amp; 1) == 1) res = res * a % m; a = a * a % m; b \u0026gt;\u0026gt;= 1; } return res; } 根据费马小定理，如果 $m$ 是一个质数，我们可以计算 $x^{n\\bmod(m-1)}$ 来加速算法过程。\n参考 [1] 快速幂 - OI Wiki\n","permalink":"https://note-site.pages.dev/posts/algorithm/%E5%BF%AB%E9%80%9F%E5%B9%82/","summary":"\u003cp\u003e快速幂，二进制取幂（Binary Exponentiation，也称平方法），是一个在 $O(\\log n)$ 的时间内计算 $a^n$ 的小技巧，而暴力的计算需要 $O(n)$ 的时间。\u003c/p\u003e\n\u003ch2 id=\"过程\"\u003e过程\u003c/h2\u003e\n\u003cp\u003e首先将 $n$ 表示为二进制，例如\u003c/p\u003e","title":"快速幂"},{"content":"0 - 1023 之间的端口号被称作 Well Konwn Ports，由 IANA 分配管理，1024 及以上的端口号可以被其它应用程序使用。\nPort Service Description 1080 Socks 代理 1313 Hugo 静态网站生成器 1521 Oracle 数据库监听端口 2049 NFS 网络文件系统 2181 Apache Zookeeper 2375 Docker REST API (HTTP) 2376 Docker REST API (HTTPS) 3000 Grafana 监控可视化平台 3306 MySQL 4200 AngularJS JS 应用设计框架 5244 AList 支持多种存储的文件列表程序 5432 PostgreSQL 5901 VNC 远程桌面控制 6000 X11 6379 Redis 8080 Jenkins CI 工具 8848 Nacos 注册中心、配置中心 8888 Jupyter Notebook\n宝塔面板 交互式笔记本\n服务器运维面板 9000 Portainer Docker 图形化工具 25565 我的世界 27017 MongoDB 参考 [1] De Facto Ports\n","permalink":"https://note-site.pages.dev/posts/linux/%E5%B8%B8%E8%A7%81%E6%9C%8D%E5%8A%A1%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7/","summary":"\u003cp\u003e0 - 1023 之间的端口号被称作 Well Konwn Ports，由 IANA 分配管理，1024 及以上的端口号可以被其它应用程序使用。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003ePort\u003c/th\u003e\n          \u003cth\u003eService\u003c/th\u003e\n          \u003cth\u003eDescription\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e1080\u003c/td\u003e\n          \u003ctd\u003eSocks 代理\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e1313\u003c/td\u003e\n          \u003ctd\u003eHugo\u003c/td\u003e\n          \u003ctd\u003e静态网站生成器\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e1521\u003c/td\u003e\n          \u003ctd\u003eOracle 数据库监听端口\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e2049\u003c/td\u003e\n          \u003ctd\u003eNFS\u003c/td\u003e\n          \u003ctd\u003e网络文件系统\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e2181\u003c/td\u003e\n          \u003ctd\u003eApache Zookeeper\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e2375\u003c/td\u003e\n          \u003ctd\u003eDocker REST API (HTTP)\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e2376\u003c/td\u003e\n          \u003ctd\u003eDocker REST API (HTTPS)\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e3000\u003c/td\u003e\n          \u003ctd\u003eGrafana\u003c/td\u003e\n          \u003ctd\u003e监控可视化平台\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e3306\u003c/td\u003e\n          \u003ctd\u003eMySQL\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e4200\u003c/td\u003e\n          \u003ctd\u003eAngularJS\u003c/td\u003e\n          \u003ctd\u003eJS 应用设计框架\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e5244\u003c/td\u003e\n          \u003ctd\u003eAList\u003c/td\u003e\n          \u003ctd\u003e支持多种存储的文件列表程序\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e5432\u003c/td\u003e\n          \u003ctd\u003ePostgreSQL\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e5901\u003c/td\u003e\n          \u003ctd\u003eVNC\u003c/td\u003e\n          \u003ctd\u003e远程桌面控制\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e6000\u003c/td\u003e\n          \u003ctd\u003eX11\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e6379\u003c/td\u003e\n          \u003ctd\u003eRedis\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e8080\u003c/td\u003e\n          \u003ctd\u003eJenkins\u003c/td\u003e\n          \u003ctd\u003eCI 工具\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e8848\u003c/td\u003e\n          \u003ctd\u003eNacos\u003c/td\u003e\n          \u003ctd\u003e注册中心、配置中心\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e8888\u003c/td\u003e\n          \u003ctd\u003eJupyter Notebook\u003cbr\u003e宝塔面板\u003c/td\u003e\n          \u003ctd\u003e交互式笔记本\u003cbr\u003e服务器运维面板\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e9000\u003c/td\u003e\n          \u003ctd\u003ePortainer\u003c/td\u003e\n          \u003ctd\u003eDocker 图形化工具\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e25565\u003c/td\u003e\n          \u003ctd\u003e我的世界\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e27017\u003c/td\u003e\n          \u003ctd\u003eMongoDB\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"参考\"\u003e参考\u003c/h2\u003e\n\u003cp\u003e[1] \u003ca href=\"https://matt-rickard.com/de-facto-ports\"\u003eDe Facto Ports\u003c/a\u003e\u003c/p\u003e","title":"常见服务默认端口号"},{"content":"安装 Scoop 见 Windows 下的包管理器：Scoop\n安装 terminal 使用的字体，推荐使用 JetBrainsMono-NF。\nsudo scoop install -k JetBrainsMono-NF 安装 Powershell 7 scoop install pwsh -k 安装并配置 on-my-posh PowerShell 7 自带 PSReadLine，在 PowerShell 5 上需要自己安装，可以通过 $PSVersionTable 命令查看当前 PowerShell 版本。\n$PSVersionTable Name Value ---- ----- PSVersion 7.3.7 PSEdition Core GitCommitId 7.3.7 OS Microsoft Windows 10.0.19045 Platform Win32NT PSCompatibleVersions {1.0, 2.0, 3.0, 4.0…} PSRemotingProtocolVersion 2.3 SerializationVersion 1.1.0.1 WSManStackVersion 3.0 以管理员身份运行 PowerShell，安装插件 set-executionpolicy remotesigned Install-Module PSReadLine -Force Install-Module posh-git Install-Module Terminal-Icons 安装 on-my-posh scoop install https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/oh-my-posh.json 下载 oh-my-posh 主题（可选） git clone https://github.com/JanDeDobbeleer/oh-my-posh 保留其中的 themes 文件夹即可。\n配置 PowerShell notepad $profile 写入以下文本。注意修改 config 路径。\n# oh-my-posh init pwsh --config D:\\Env\\oh-my-posh\\themes\\my\\sail.omp.json | Invoke-Expression # Import-Module posh-git # Import-Module Terminal-Icons # Import-Module scoop-completion # Shows navigable menu of all options when hitting Tab Set-PSReadlineKeyHandler -Key Tab -Function MenuComplete # 设置 Ctrl+z 为撤销 Set-PSReadLineKeyHandler -Key \u0026#34;Ctrl+z\u0026#34; -Function Undo # 设置向上键为后向搜索历史记录 Set-PSReadlineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向下键为前向搜索历史纪录 Set-PSReadlineKeyHandler -Key DownArrow -Function HistorySearchForward # 设置预测文本来源为历史记录 # Set-PSReadLineOption -PredictionSource History # ListView Set-PSReadLineOption -PredictionSource History -PredictionViewStyle ListView # 每次回溯输入历史，光标定位于输入内容末尾 Set-PSReadLineOption -HistorySearchCursorMovesToEnd # 打开当前工作目录 function OpenCurrentFolder { param ( # 输入要打开的路径 # 用法示例：open C:\\ # 默认路径：当前工作文件夹 $Path = \u0026#39;.\u0026#39; ) Invoke-Item $Path } Set-Alias -Name open -Value OpenCurrentFolder 重新打开 terminal 查看。\n配置 Windows Terminal 修改配置文件 settings.json，具体文件见附件。\n注意修改 backgroundImage 路径 。\n右键在此处打开 Terminal 将以下文本保存为 .reg 文件并执行，或下载附件执行。\n注意：需要下载 terminal.ico 图标文件（见附件），如果不生效试试把 wt 改成 windows terminal 完整路径。\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\directory\\background\\shell\\wt] @=\u0026#34;Open Terminal\u0026#34; \u0026#34;icon\u0026#34;=\u0026#34;%LOCALAPPDATA%\\\\Microsoft\\\\WindowsApps\\\\terminal.ico\u0026#34; [HKEY_CLASSES_ROOT\\directory\\background\\shell\\wt\\command] @=\u0026#34;wt -d .\u0026#34; 参考 [1] 我的windows terminal美化方案（oh-my-posh3）\n[2] 魔改的一个posh3主题\n[3] Win11下安装PSReadLine终端自动补全\n附件 bg.png (2 MB) sail.omp.json (3 KB) settings.json (1 KB) terminal.ico (50 KB) 添加terminal至右键菜单.reg (500 B) ","permalink":"https://note-site.pages.dev/posts/windows/terminal-beautify/","summary":"\u003ch2 id=\"安装-scoop\"\u003e安装 Scoop\u003c/h2\u003e\n\u003cp\u003e见 \u003ca href=\"../scoop\"\u003eWindows 下的包管理器：Scoop\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e安装 terminal 使用的字体，推荐使用 JetBrainsMono-NF。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-powershell\" data-lang=\"powershell\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003esudo\u003c/span\u003e \u003cspan class=\"n\"\u003escoop\u003c/span\u003e \u003cspan class=\"n\"\u003einstall\u003c/span\u003e \u003cspan class=\"n\"\u003e-k\u003c/span\u003e \u003cspan class=\"nb\"\u003eJetBrainsMono-NF\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"安装-powershell-7\"\u003e安装 Powershell 7\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-fallback\" data-lang=\"fallback\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003escoop install pwsh -k\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"安装并配置-on-my-posh\"\u003e安装并配置 on-my-posh\u003c/h2\u003e\n\u003cp\u003ePowerShell 7 自带 PSReadLine，在 PowerShell 5 上需要自己安装，可以通过 \u003ccode\u003e$PSVersionTable\u003c/code\u003e 命令查看当前 PowerShell 版本。\u003c/p\u003e","title":"Windows Terminal 美化"},{"content":"逆元 逆元通常是用来解决除法求模问题的，求模运算有以下法则：\n$$ \\begin{cases} (a+b)\\%c\u0026=\u0026(a\\%c+b\\%c)\\%c\\quad \u0026加法法则\\\\[1ex] (a-b)\\%c\u0026=\u0026(a\\%c-b\\%c)\\%c\\quad \u0026减法法则\\\\[1ex] (a*b)\\%c\u0026=\u0026(a\\%c*b\\%c)\\%c\\quad \u0026乘法法则 \\end{cases} $$ 可以发现，除法求模没有相应的法则。当计算 $\\cfrac{a}{b}\\%c$ 时，如果 $a$，$b$ 很大，不能在计算完之后取模，可以通过变换将除法变为乘法，然后就可以通过上面的公式取模了。\n设 $b*k\\%c=1$ ，则有\n$$ \\cfrac{a}{b}\\%c=\\cfrac{a}{b}\\%c*(b*k\\%c)=(a*k)\\%c $$这样就把除法转化为了乘法，这里的 $k$ 就叫做 $b$ 关于 $c$ 的乘法逆元，写成数学表达式就是\n$$ bk\\equiv1\\pmod c $$定义 若 $p$ 为素数，$\\gcd (a,p)=1$ （即 $a,p$ 互质），有 $a^{p-1}\\equiv1\\pmod{p}$\n另一种形式：对于任意整数 $a$，有 $a^p\\equiv a\\pmod{p}$\n乘法逆元形式：$a×a^{p-2}\\equiv1\\pmod p$ ，即 $a$ 的逆元是 $a^{p-2}$。\n证明 数学归纳法证明：\n显然 $1^p\\equiv 1\\pmod{p}$，假设 $a^p\\equiv a\\pmod{p}$ 成立，需要证明 $(a+1)^p\\equiv a+1\\pmod{p}$。\n$$ \\begin{aligned} \u0026二项式定理： (a+1)^p=a^p+\\begin{pmatrix}p\\\\1 \\end{pmatrix}a^{p-1}+\\begin{pmatrix}p\\\\2 \\end{pmatrix}a^{p-2}+\\cdots+\\begin{pmatrix}p\\\\p-1 \\end{pmatrix}a+1\\\\[1ex] \u0026\\because 1\\le k\\le p-1时，\\begin{pmatrix}p\\\\k \\end{pmatrix}=\\cfrac{p(p-1)\\cdots(p-k+1)}{k!}\\\\ \u0026\\therefore \\begin{pmatrix}p\\\\1 \\end{pmatrix}\\equiv \\begin{pmatrix}p\\\\2 \\end{pmatrix}\\equiv \\cdots\\equiv \\begin{pmatrix}p\\\\p-1 \\end{pmatrix}\\equiv0\\pmod{p}\\\\[1ex] \u0026\\therefore(a+1)^p\\equiv a^p+1\\pmod{p}\\\\[1ex] \u0026\\because a^p\\equiv a\\pmod{p}\\\\[1ex] \u0026\\therefore (a+1)^p\\equiv a+1\\pmod{p}\\\\[1ex] \u0026\\therefore原式得证 \\end{aligned} $$求解组合数 求解 $C_m^n$ ，最终结果对 $10^9+7$ 取模。\n方法一：由杨辉三角有 $C_m^n = C_{m-1}^{n-1} + C_{m-1}^{n}$ ，可以通过动态规划求解，时间复杂度 $O(N^2)$\nint f(int m, int n) { int[][] dp = new int[m + 1][n + 1];\tfor (int i = 0; i \u0026lt; m + 1; i++) dp[i][0] = 1; // C_m^0 = 1 for (int i = 1; i \u0026lt; m + 1; i++) { for (int j = 1; j \u0026lt; n + 1; j++) { dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD; } } return dp[m][n]; } 方法二：快速幂+费马小定理\n$$ \\begin{align*} C_m^n \u0026= \\cfrac{m!}{(m-n)!*n!}\\%MOD\\\\[1ex] \u0026= \\cfrac{(m-n+1)*(m-n+2)*...*m}{1*2*...*n}\\% MOD \\\\ \\end{align*} $$设 $a=(m-n+1)*(m-n+2)*\\ldots *m,b=1*2*\\ldots *n$，那么现在就要求 $b$ 对于 $p$ 的乘法逆元。将原式拆分为 $\\cfrac{a}{1}*\\cfrac{a}{2}*...\\cfrac{a}{n}$，则只需要计算 $i(1\\le i\\le n)$ 的逆元。根据费马小定理得逆元 $k = i^{p-2} \\%p$ 。\n// 非递归快速幂对p取模 public int nqpow(int a, int n, int p) { long res = 1, a1 = a; while (n != 0) { if ((n \u0026amp; 1) == 1) { // n是奇数 res = res * a1 % p;\t// 注意此处和下面不能缩写成 res *= a1 % p; } a1 = a1 * a1 % p; n \u0026gt;\u0026gt;= 1; } return (int) res; } int f(int m, int n) { long res = 1; for (int i = m - n + 1; i \u0026lt;= m; i++) res = res * i % MOD; // 计算分子 for (int i = 1; i \u0026lt;= n; i++) res = res * nqpow(i, MOD - 2, MOD) % MOD; // 计算分母 return (int) res; } 参考 [1] 欧拉定理 \u0026amp; 费马小定理\n","permalink":"https://note-site.pages.dev/posts/algorithm/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/","summary":"\u003ch2 id=\"逆元\"\u003e逆元\u003c/h2\u003e\n\u003cp\u003e逆元通常是用来解决除法求模问题的，求模运算有以下法则：\u003c/p\u003e\n$$\n\\begin{cases}\n(a+b)\\%c\u0026=\u0026(a\\%c+b\\%c)\\%c\\quad \u0026加法法则\\\\[1ex]\n(a-b)\\%c\u0026=\u0026(a\\%c-b\\%c)\\%c\\quad \u0026减法法则\\\\[1ex]\n(a*b)\\%c\u0026=\u0026(a\\%c*b\\%c)\\%c\\quad \u0026乘法法则\n\\end{cases}\n$$\u003cp\u003e\n可以发现，除法求模没有相应的法则。当计算 $\\cfrac{a}{b}\\%c$ 时，如果 $a$，$b$ 很大，不能在计算完之后取模，可以通过变换将除法变为乘法，然后就可以通过上面的公式取模了。\u003c/p\u003e","title":"费马小定理"},{"content":" Interpreter Pattern: Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.\n解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n解释器模式是一种使用频率较低且学习难度较大的设计模式，它用于描述如何使用面向对象语言构成一个简单的语言解释器。在解释器模式的定义中所指的“语言”是使用规定格式和语法的代码，解释器模式是一种类行为型模式。\n文法规则和抽象语法树 在分析解释器模式之前首先需要了解如何表示一个语言的文法规则以及如何构造一棵抽象语法树。以加/减法解释器为例，每个输入表达式（例如1+2+3-4+1）都包含了 3 个语言单位，可以使用以下文法规则定义：\nexpression ::= value | operation operation ::= expression \u0026#39;+\u0026#39; expression | expression \u0026#39;-\u0026#39; expression value ::= an integer\t// 一个整数值 该文法规则通过巴科斯范式（BNF）定义，::= 表示 “定义为”，| 表示 “或者”。\n该文法规则包含三条语句，第一条是表达式的组成方式，其中 value 和 operation 是后面两个语言单位的定义，每一条语句所定义的字符串（如 value 和 operation）称为语言单位，其对应着终结表达式和非终结表达式。例如本例中的 operation 是非终结表达式，因为它的组成元素仍可以是表达式，而 value 是终结表达式，因为它的组成元素是最基本的语言单位，不可以再分解。\n除了使用文法规则来定义一个语言外，还可以使用抽象语法树的图形方式来直观表示语言的构成。每一个抽象语法树都表示一个语言实例，例如语句 1+2+3-4+1可以表示为：\n在抽象语法树中，终结表达式作为叶子结点，非终结表达式作为非叶子节点。\n解释器模式结构 解释器模式结构与组合模式结构类似，其包含 4 个角色：\n（1）AbstractExpression（抽象表达式）：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。\n（2）TerminalExpression（终结表达式）：终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子。\n（3）NonTerminalExpression（非终结表达式）：非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由千在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式完成。\n（4）Context（环境类）：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。\n解释器模式实现 在解释器模式中每一种终结符和非终结符都有一个具体类对应。\n抽象表达式类实现如下：\npublic abstract class AbstractExpression { public abstract void interpret(Context ctx); } 终结符表达式类实现如下：\npublic class TerminalExpression extends AbstractExpression { public void interpret(Context ctx) { // 终结符表达式的解释操作 } } 非终结符表达式类典型实现如下：\npublic class NonterminalExpression extends AbstractExpression { public AbstractExpression left; public AbstractExpression right; public NonterminalExpression(AbstractExpression left, AbstractExpression right) { this.left = left; this.right = right; } public void interpret(Context ctx) { // 递归调用每一个组成部分的 interpret 方法 // 在递归调用时指定组成部分的连接方式，即非终结符的功能 } } 环境类通常包含一个HashMap或ArrayList等类型的集合对象，存储一系列公共信息。\npublic class Context { public Map\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); // 往环境类设值 public void assign(String key, String val) { map.put(key, val); } // 获取环境类的值 public void lookup(String key) { map.get(key); } } 环境类还可以提供一些所有表达式解释器共有的功能。当系统无需提供全局公共信息时可以省略环境类。\n应用实例 某软件公司要开发一套机器人控制程序，在该机器人控制程序中包含一些简单的英文控制指令，每一个指令对应一个表达式（expression），该表达式可以是简单表达式也可以是复合表达式，每一个简单表达式由移动方向（direction），移动方式（action）和移动距离（distance）3 部分组成，其中移动方向包括上（up）、下（down）、左（left）、右（right）；移动方式包括移动（move）和快速移动（run）；移动距离为一个正整数。两个表达式之间可以通过与（and）连接形成复合（composite）表达式。用户通过对图形化的设置界面进行操作可以创建一个机器人控制指令，机器人在收到指令后将按照指令的设置进行移动，例如输入控制指令 “up move 5\u0026quot;，则 “向上移动 5 个单位”；输入控制指令 “down run 10 and left move 20“，则 “向下快速移动 10 个单位再向左移动 20 个单位”。现使用解释器模式来设计该程序并模拟实现。\n实现 使用 BNF 定义该语言的文法规则如下：\nexpression ::= direction action distance | composite\t// 表达式 composite ::= expression \u0026#39;and\u0026#39; expression\t// 复合表达式 direction ::= \u0026#39;left\u0026#39; | \u0026#39;right\u0026#39; | \u0026#39;up\u0026#39; | \u0026#39;down\u0026#39;\t// 移动方向 actoin ::= \u0026#39;move\u0026#39; | \u0026#39;run\u0026#39;\t// 移动方式 distance ::= an integer\t// 移动距离 机器人控制实例结构图如下所示：\n（1）AbstractNode：抽象结点类，充当抽象表达式角色\npublic abstract class AbstractNode { public abstract String interpret(); } （2）AndNode：And 结点类，充当非终结表达式角色\npublic class AndNode extends AbstractNode { public AbstractNode left; public AbstractNode right; public AndNode(AbstractNode left, AbstractNode right) { this.left = left; this.right = right; } public String interpret() { return this.left.interpret() + \u0026#34;再\u0026#34; + this.right.interpret(); } } （3）SentenceNode：简单句子结点类，充当非终结表达式角色\npublic class SentenceNode extends AbstractNode { public AbstractNode direction; public AbstractNode action; public AbstractNode distance; //省略全参构造函数 ... public String interpret() { return direction.interpret() + action.interpret() + distance.interpret(); } } （4）三个终结符表达式角色\n// 方向结点类 public class Direction extends AbstractNode { public String direction; public Direction(String direction) { this.direction = direction; } public String interpret() { switch(direction.toLowerCase()) { case \u0026#34;up\u0026#34; -\u0026gt; { return \u0026#34;向上\u0026#34;; } case \u0026#34;down\u0026#34; -\u0026gt; { return \u0026#34;向下\u0026#34;; } case \u0026#34;left\u0026#34; -\u0026gt; { return \u0026#34;向左\u0026#34;; } case \u0026#34;right\u0026#34; -\u0026gt; { return \u0026#34;向右\u0026#34;; } default -\u0026gt; { return \u0026#34;无效指令\u0026#34;; } } } } // 行为结点类 public class Action extends AbstractNode { public String action; public Action(String action) { this.action = action; } public String interpret() { switch(action.toLowerCase()) { case \u0026#34;move\u0026#34; -\u0026gt; { return \u0026#34;移动\u0026#34;; } case \u0026#34;run\u0026#34; -\u0026gt; { return \u0026#34;快速移动\u0026#34;; } default -\u0026gt; { return \u0026#34;无效指令\u0026#34;; } } } } // 行为结点类 public class Distance extends AbstractNode { public String distance; public Distance(String distance) { this.distance = distance; } public String interpret() { return distance + \u0026#34;m\u0026#34;; } } （4）InstructionHandler：指令处理类，工具类，提供相应的方法对输入指令进行处理。它将输入指令分割为字符串数组，将第一个、第二个和第三个单词组合成一个句子，并存入栈中；如果发现有单词 “and\u0026quot;，则将 “and” 后的第一个、第二个和第三个单词组合成一个新的句子作为 \u0026ldquo;and” 的右表达式，并从栈中取出原先所存的句子作为左表达式，然后组合成一个 And 结点存入栈中。依此类推，直到整个指令解析结束。\npublic class InstructionHandler { private AbstractNode node; public void handle(String instruction) { AbstractNode left, right; AbstractNode direction, action, distance; Stack\u0026lt;AbstractNode\u0026gt; stack = new Stack\u0026lt;\u0026gt;();\t// 创建栈用于临时存放结点 String[] words = instruction.split(\u0026#34; \u0026#34;); for (int i = 0; i \u0026lt; words.length; i++) { /* 遇到 and 则将之后三个单词作为三个终结符表达式连接成 SentenceNode，作为右表达式，栈顶元素作为左表达式，最后连接成 AndNode 并压入栈中 */ if (words[i].equalsIgnoreCase(\u0026#34;and\u0026#34;)) { left = stack.pop(); direction = new DirectionNode(words[++i]); action = new ActionNode(words[++i]); distance = new DistanceNode(words[++i]); right = new SentenceNode(direction, action, distance); stack.push(new AndNode(left, right)); } else { /* 否则逐个解释连接成 SentenceNode */ direction = new DirectionNode(words[i++]); action = new ActionNode(words[i++]); distance = new DistanceNode(words[i]); stack.push(new SentenceNode(direction, action, distance)); } } this.node = stack.pop();\t// 存储栈中的结点 } public String output() { return this.node.interpret(); } } （5）Client：客户端测试类\npublic class Client { public static void main(String[] args) { String instruction = \u0026#34;down run 10 and left move 20\u0026#34;; InstructionHandler handler = new InstructionHandler(); handler.handle(instruction); System.out.println(handler.output()); } } 优缺点与适用环境 优点：\n易于改变和扩展语法。解释器模式中可以通过类继承等机制扩展文法。\n增加新的解释表达式比较方便。只需要对应增加一个新的终结符表达式类或非终结符表达式类即可。\n缺点：\n复杂文法难以维护。如果一个语言包含太多文法规则，类的个数会急剧增加，导致系统难以管理和维护。此时可以考虑使用语法分析程序取代解释器模式。\n执行效率较低。解释器模式使用了大量的递归调用，在解释较复杂的句子时速度很慢。\n适用环境：\n可以将一个需要解释执行的语言中的句子表示为一棵抽象语法树。\n语言文法较为简单。\n执行效率不敏感。\n参考 《Java 设计模式》．刘伟．清华大学出版社\n","permalink":"https://note-site.pages.dev/posts/design-pattern/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/","summary":"\u003cblockquote\u003e\n\u003cp\u003eInterpreter Pattern: Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.\u003c/p\u003e\n\u003cp\u003e解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\u003c/p\u003e","title":"解释器模式"},{"content":"TopK 问题指的是寻找数组第 $K$ 大/小的元素。一种简单的做法是对数组排序，然后取第 $K$ 个元素，时间复杂度为 $O(NlogN)$，接下来以寻找第 $K$ 大的元素为例，介绍另外两种做法。\n快速选择算法 在快速排序算法中，每一轮排序至少会将一个元素排列到正确位置上，该元素左侧元素均小于它，右侧元素均大于它，基于此性质，我们可以快速找到这样一个元素：在满足快速排序的同时，它右侧的元素正好有 $K - 1$ 个。\npublic int select(int[] arr, int k, int l, int r) { if (l \u0026gt; r) { return -1; } int i = l, j = r; // 随机交换，尽量避免最坏情况 swap(arr, l, (int) Math.floor(Math.random() * (r - i + 1)) + l); int pivot = arr[i]; // 快速排序算法内容 while (i \u0026lt; j) { while (i \u0026lt; j \u0026amp;\u0026amp; arr[j] \u0026gt; pivot) { j--; } if (i \u0026lt; j) { arr[i++] = arr[j]; } while (i \u0026lt; j \u0026amp;\u0026amp; arr[i] \u0026lt; pivot) { i++; } if (i \u0026lt; j) { arr[j--] = arr[i]; } } arr[i] = pivot; // 计算当前排名 int rank = r - i + 1; if (rank == k) { return arr[i]; } if (rank \u0026gt; k) { return select(arr, k, i + 1, r); } // 注意k发生了变化 return select(arr, k - rank, l, i - 1); } /** * 返回数组中第 k 大的元素 * @param k 1\u0026lt;=k\u0026lt;=arr.length * @return 数组中第 k 大的元素 */ public int select(int[] arr, int k) { if (arr == null || k \u0026gt; arr.length || k \u0026lt; 1) { return -1; } return select(arr, k, 0, arr.length - 1); } 快速选择算法平均和最好时间复杂度为 $O(N)$，最坏时间复杂度为 $O(N^2)$ ，因为我们已经随机选择 pivot，所以能够最大程度上的减少最坏情况发生。空间复杂度和快速排序一致： $O(logN)$。注意此算法会破坏原数组结构。\n最小堆 维护一个大小为 $K$ 的最小堆，遍历数组，将数组中大于堆顶的元素加入堆中，最后堆顶的元素就是我们要找的第 $K$ 大的数。\npublic int select(int[] arr, int k) { if (arr == null || k \u0026gt; arr.length || k \u0026lt; 1) { return -1; } Queue\u0026lt;Integer\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;(k); for (int i : arr) { if (queue.size() \u0026lt; k) { queue.add(i); } else if (i \u0026gt; queue.peek()) { queue.poll(); queue.add(i); } } return queue.poll(); } 此算法的时间复杂度为 $O(NlogK)$，空间复杂度为 $O(K)$。\n对顶堆 考察下面这个问题\n维护一个序列，支持两种操作：\n向序列中插入一个元素 输出并删除当前序列的中位数（若序列长度为偶数，则输出较小的中位数） 这个问题可以被进一步抽象成：动态维护一个序列上第 $K$ 大的数，$K$ 值可能会发生变化。对于此类问题，我们可以使用 对顶堆 这一技巧予以解决。\n对顶堆由一个大根堆与一个小根堆组成，小根堆维护大值即前 $K$ 大的值（包含第 $K$ 个)，大根堆维护小值即比第 $K$ 大数小的其他数。\n这两个堆构成的数据结构支持以下操作：\n维护：当小根堆的大小小于 $K$ 时，不断将大根堆堆顶元素取出并插入小根堆，直到小根堆的大小等于 $K$；当小根堆的大小大于 $K$ 时，不断将小根堆堆顶元素取出并插入大根堆，直到小根堆的大小等于 $K$； 插入元素：若插入的元素大于等于小根堆堆顶元素，则将其插入小根堆，否则将其插入大根堆，然后维护对顶堆； 查询第 $K$ 大元素：小根堆堆顶元素即为所求； 删除第 $K$ 大元素：删除小根堆堆顶元素，然后维护对顶堆； $K$ 值 $+1/-1$：根据新的 $K$ 值直接维护对顶堆。 显然，查询第 $k$ 大元素的时间复杂度是 $O(1)$ 的。由于插入、删除或调整 $K$ 值后，小根堆的大小与期望的值 $K$ 最多相差 $1$，故每次维护最多只需对大根堆与小根堆中的元素进行一次调整，因此，这些操作的时间复杂度都是 $O(\\log N)$ 的。\npublic class MedianHeap { // 大根堆 public Queue\u0026lt;Integer\u0026gt; a; // 小根堆 public Queue\u0026lt;Integer\u0026gt; b; public MedianHeap() { a = new PriorityQueue\u0026lt;\u0026gt;(Comparator.reverseOrder()); b = new PriorityQueue\u0026lt;\u0026gt;(); } public void insert(int x) { if (!b.isEmpty() \u0026amp;\u0026amp; x \u0026gt; b.peek()) { b.offer(x); } else { a.offer(x); } balance(); } public int median() { int ans; if (b.size() \u0026gt; a.size()) { ans = b.poll(); } else { ans = a.isEmpty() ? -1 : a.poll(); } balance(); return ans; } private void balance() { if (Math.abs(a.size() - b.size()) \u0026gt; 1) { Queue\u0026lt;Integer\u0026gt; more = a.size() \u0026gt; b.size() ? a : b; Queue\u0026lt;Integer\u0026gt; less = more == a ? b : a; while (more.size() - less.size() \u0026gt; 1) { less.offer(more.poll()); } } } } 参考 [1] Top K 问题的最优解 - 快速选择算法（Quickselect）\n[2] 快速排序\n[3] 二叉堆 #对顶堆\n","permalink":"https://note-site.pages.dev/posts/algorithm/topk-%E9%97%AE%E9%A2%98/","summary":"\u003cp\u003eTopK 问题指的是寻找数组第 $K$ 大/小的元素。一种简单的做法是对数组排序，然后取第 $K$ 个元素，时间复杂度为 $O(NlogN)$，接下来以寻找第 $K$ 大的元素为例，介绍另外两种做法。\u003c/p\u003e","title":"TopK 问题"},{"content":"if fn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!(\u0026#34;The value of number is: {}\u0026#34;, number); } 以上代码有以下几点要注意：\nif 语句块是表达式，这里我们使用 if 表达式的返回值来给 number 进行赋值：number 的值是 5 用 if 来赋值时，要保证每个分支返回的类型一样(事实上，这种说法不完全准确，见这里)，此处返回的 5 和 6 就是同一个类型，如果返回类型不一致就会报错 for 循环 以下代码会循环输出一个从 1 到 5 的序列\nfn main() { for i in 1..=5 { println!(\u0026#34;{}\u0026#34;, i); } } 使用for循环时往往使用集合的引用形式，否则所有权会 move 到for语句块中，后续就无法再使用了。\n使用方法 等价使用方式 所有权 for item in collection for item in IntoIterator::into_iter(collection) 转移所有权 for item in \u0026amp;collection for item in collection.iter() 不可变借用 for item in \u0026amp;mut collection for item in collection.iter_mut() 可变借用 在循环中获取索引：\nfn main() { let arr = [1,2,3,4,5]; // .iter() 方法把 arr 数组变成一个迭代器 for (i, v) in arr.iter().enumerate() { println!(\u0026#34;{}: {}\u0026#34;, i, v); } } 控制循环执行 10 次：\nfn main() { for _ in 0..10 { // do something } } loop 循环 loop循环是简单的无限循环，可以在内部通过 break 控制循环结束。\nfn main() { loop { // do something } } loop 是一个表达式，因此可以返回一个值\nfn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; println!(\u0026#34;{}\u0026#34;, result);\t// 20 } while 循环 rust 的 while 循环和 Java 类似。\n循环标签 当有多层循环时，你可以使用 continue 或 break 来控制外层的循环。要实现这一点，外部的循环必须拥有一个标签 'label, 然后在 break 或 continue 时指定该标签。\nfn main() { let mut count = 0; \u0026#39;outer: loop { \u0026#39;inner1: loop { if count \u0026gt;= 20 { // 这只会跳出 inner1 循环 break \u0026#39;inner1; // 这里使用 `break` 也是一样的 } count += 2; } count += 5; if count \u0026gt;= 30 { break \u0026#39;outer; } } assert!(count == 30) } ","permalink":"https://note-site.pages.dev/posts/rust/rust-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","summary":"\u003ch2 id=\"if\"\u003eif\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-rust\" data-lang=\"rust\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efn\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003econdition\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003enumber\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003econdition\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"k\"\u003eelse\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e    \u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e  \u003c/span\u003e\u003cspan class=\"fm\"\u003eprintln!\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;The value of number is: \u003c/span\u003e\u003cspan class=\"si\"\u003e{}\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003enumber\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e以上代码有以下几点要注意：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eif\u003c/code\u003e 语句块是表达式\u003c/strong\u003e，这里我们使用 \u003ccode\u003eif\u003c/code\u003e 表达式的返回值来给 \u003ccode\u003enumber\u003c/code\u003e 进行赋值：\u003ccode\u003enumber\u003c/code\u003e 的值是 \u003ccode\u003e5\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e用 \u003ccode\u003eif\u003c/code\u003e 来赋值时，要保证每个分支返回的类型一样(事实上，这种说法不完全准确，见\u003ca href=\"https://course.rs/appendix/expressions.html#if%E8%A1%A8%E8%BE%BE%E5%BC%8F\"\u003e这里\u003c/a\u003e)，此处返回的 \u003ccode\u003e5\u003c/code\u003e 和 \u003ccode\u003e6\u003c/code\u003e 就是同一个类型，如果返回类型不一致就会报错\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"for-循环\"\u003efor 循环\u003c/h2\u003e\n\u003cp\u003e以下代码会循环输出一个从 1 到 5 的序列\u003c/p\u003e","title":"Rust 流程控制"},{"content":"文件类型识别是指根据文件的二进制数据判断文件的类型。以下是几种常见的文件类型识别方法：文件类型识别是在很多应用场景都需要用到的功能，比如在Web开发中，通常需要根据上传文件的类型进行不同的处理；在文件管理系统中，对不同文件类型展示不同的图标和操作等。文件类型识别的方法通常有以下几种：\n文件扩展名：根据文件扩展名确定文件类型，优点是效率高，缺点是文件扩展名可以被修改，准确性低。 文件内容特征：不同类型的文件具有不同的内容特征，例如MP3音频的内容特征是以 ID3 标签开头。 魔数：魔数是文件头部的一些特定字节，用来标识文件类型。不同类型的文件类型有不同的魔数值。 标准库实现 Go 语言的标准库net/http包中提供了一个判断文件类型的方法 DetectContentType(data []byte)，它接收文件内容的前 512 个字节作为参数，返回 MIME 类型字符串，例如text/plain; charset=utf-8。其实现流程为：首先截取输入字节数组的前 512 个字节，然后遍历找到第一个不是空格的字节，从这个字节开始遍历预定义的 MIME 类型的匹配规则按顺序匹配，如果没有找到匹配类型，最终会返回application/octet-stream。\n下面是一个示例：\nfunc TestStd(t *testing.T) { file, err := os.Open(\u0026#34;../res.txt\u0026#34;) if err != nil { fmt.Printf(\u0026#34;文件打开失败，%v\\n\u0026#34;, err) return } defer file.Close() // 读取文件前 512 个字节 buf := make([]byte, 512) if _, err := file.Read(buf); err != nil { fmt.Printf(\u0026#34;文件读取失败，%v\\n\u0026#34;, err) return } // 调用DetectContentType方法判断文件类型 contentType := http.DetectContentType(buf) fmt.Println(contentType) } mime.ExtensionsByType(typ string)方法可以返回指定 MIME 类型关联的拓展名类型数组，并且返回值总以 . 开头，例如 \u0026ldquo;.html\u0026rdquo;。\next, _ := mime.ExtensionsByType(\u0026#34;image/jpeg\u0026#34;) fmt.Println(ext)\t// [.jfif .jpe .jpeg .jpg] 标准库实现的优点是简单易用，缺点是能够识别的类型较少，准确率一般。\n第三方库 filetype filetype 是一个 Go 语言的第三方库，用于识别文件类型。它支持识别超过 400 种不同类型的文件，包括常见的图像、音频、视频、文档和归档文件等。它的特点有：\n可以根据扩展名或 MIME 类型来发现文件类型 可以根据类别（图片、视频、音频等）来发现文件类型 可以添加自定义的新类型和匹配器 只需要前 262 字节表示最大的文件头，所以你可以只传递一个切片 filetype 是基于文件的魔数进行类型检测的。filetype 在初始化时会将所有定义的文件类型和对应的匹配器添加到全局 map 中，然后在核心方法 Match 中，它会逐个遍历 map 中的匹配器，如果返回值不是Unknown则直接返回结果，如果都不匹配则返回自定义类型Unknown。\n以下是一个使用示例：\nfunc TestFileType(t *testing.T) { buf, _ := os.ReadFile(\u0026#34;G:\\\\Sf\\\\001.jpg\u0026#34;) kind, _ := filetype.Match(buf) if kind == filetype.Unknown { fmt.Println(\u0026#34;Unknown file type\u0026#34;) return } fmt.Println(\u0026#34;File type:\u0026#34;, kind.Extension) fmt.Println(\u0026#34;MIME type:\u0026#34;, kind.MIME.Value) } filetype 还提供了一些辅助函数，例如IsImage(buf)、IsVideo(buf)、IsAudio(buf)等，用于检测文件是否属于某个类别，它会遍历特定类别的所有匹配器，并返回是否有匹配器返回 true。\nfunc main() { file, _ := os.Open(\u0026#34;G:\\\\Sf\\\\001.jpg\u0026#34;) buf := make([]byte, 261)\t// 只需要前261个字节 _, _ = file.Read(buf) isImage := filetype.IsImage(buf) fmt.Println(isImage) } filetype 还可以添加额外的类型和匹配器\nvar fooType = filetype.NewType(\u0026#34;foo\u0026#34;, \u0026#34;foo/foo\u0026#34;) func fooMatcher(buf []byte) bool { return len(buf) \u0026gt; 1 \u0026amp;\u0026amp; buf[0] == 0x01 \u0026amp;\u0026amp; buf[1] == 0x02 } func main() { // Register the new matcher and its type filetype.AddMatcher(fooType, fooMatcher) // Check if the new type is supported by extension if filetype.IsSupported(\u0026#34;foo\u0026#34;) { fmt.Println(\u0026#34;New supported type: foo\u0026#34;) } // Check if the new type is supported by MIME if filetype.IsMIMESupported(\u0026#34;foo/foo\u0026#34;) { fmt.Println(\u0026#34;New supported MIME type: foo/foo\u0026#34;) } // Try to match the file fooFile := []byte{0x01, 0x02} kind, _ := filetype.Match(fooFile) if kind == filetype.Unknown { fmt.Println(\u0026#34;Unknown file type\u0026#34;) } else { fmt.Printf(\u0026#34;File type matched: %s\\n\u0026#34;, kind.Extension) } } filetype 库优点：\n支持更多种类和更细分的文件类型，比如视频、音频、文档等。 提供更准确和更规范化的 MIME 类型，比如 image/jpeg 而不是 image/jpg。 效率更高，因为只需要前 262 个字节 参考 [1] Go 标准库的神秘功能：如何轻松识别任何文件类型\n[2] Go 每日一库之文件类型鉴别利器 filetype\n","permalink":"https://note-site.pages.dev/posts/go/%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB/","summary":"\u003cp\u003e文件类型识别是指根据文件的二进制数据判断文件的类型。以下是几种常见的文件类型识别方法：文件类型识别是在很多应用场景都需要用到的功能，比如在Web开发中，通常需要根据上传文件的类型进行不同的处理；在文件管理系统中，对不同文件类型展示不同的图标和操作等。文件类型识别的方法通常有以下几种：\u003c/p\u003e","title":"文件类型识别"},{"content":"切片 切片允许你引用集合中部分连续的元素序列，而不是引用整个集合。切片的长度无法在编译期得知，所以不能直接使用切片类型。切片只能使用引用类型。切片引用（如无说明，以下均用切片指代切片引用）占用两个字的内存空间，第一个字是指向数据的指针，第二个字是切片的长度。在x86-64架构的机器上，一个字是 64 位即 8 字节，所以切片就是 16 字节。\nfn main() { // [i32; 5]中i32表示数组元素类型，5表示数组长度 let arr: [i32; 5] = [1,2,3,4,5]; // 切片类型只能是引用 let slice: \u0026amp;[i32] = \u0026amp;arr[1..4]; assert_eq!(slice, \u0026amp;[2,3,4]); } 字符串和字符 常用的两个类型：\u0026amp;str和String fn main() { let s1: str = \u0026#34;hello \u0026#34;; let s1: String = String::from(\u0026#34;world\u0026#34;); } 只能将String和\u0026amp;str类型进行拼接，并且String类型的所有权在此过程中会被 move \u0026amp;String可以被隐式地转换为 \u0026amp;str类型 fn main() { let s1 = String::from(\u0026#34;hello,\u0026#34;); let s1 = String::from(\u0026#34;world\u0026#34;); // s1 的所有权已经转移了 let s3 = s1 + \u0026amp;s2; // 此时已经访问不到 s1 了 // println!(\u0026#34;{}\u0026#34;, s1); } // + 调用的实际上是 std::string 中的 add 方法，其定义为： fn add(self, s: \u0026amp;str) -\u0026gt; String \u0026amp;str与String的转换 fn main() { let s1: String = \u0026#34;hello\u0026#34;.to_string(); let s2: String = String::from(\u0026#34;hello\u0026#34;); let s3: \u0026amp;str = \u0026amp;s2; } Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4) 元组 过长的元组无法被打印输出 // 最多打印长度为 12 的元组 fn main() { let too_long_tuple = (1,2,3,4,5,6,7,8,9,10,11,12,13); println!(\u0026#34;{}\u0026#34;, too_long_tuple);\t// error } 元组使用 fn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let (len, s2) = calc_len(s1); println!(\u0026#34;len of \\\u0026#34;{}\\\u0026#34; is {}\u0026#34;, s2, len);\t// len of \u0026#34;hello\u0026#34; is 5 } // 返回元组 fn calc_len(s: String) -\u0026gt; (usize, String) { // 不能写成(s, s.len())，因为s.len()调用前s的所有权已经转移 (s.len(), s) } 结构体 预定义User结构体：\nstruct User { active: bool, username: String, email: String, sign_in_count: u64, } 初始化实例时，每个字段都需要进行初始化，但是字段初始化顺序可以和定义顺序不一致\n必须要将结构体实例声明为可变的，才能修改其中的字段。Rust 不支持将结构体的某个字段标记为可变。\n简化结构体创建。当函数参数与结构体字段同名时可以使用简化方式。\nfn build_user(username: String, email: String) -\u0026gt; User { User { username, email, active: true, sign_in_count: 1 } } 简化结构体更新。..语法表明凡是没有显式声明的字段都从user1中获取，注意..user1必须写在结构体的尾部。user1会发生所有权转移，不能继续被使用，但是其内部没有发生赋值的字段或者包含 Copy trait的字段仍然可以使用。 let user1 = User { email: String::from(\u0026#34;one@mail.com\u0026#34;), username: String::from(\u0026#34;nobody\u0026#34;), active: true, sign_in_count: 1, }; let _user2 = User { email: String::from(\u0026#34;another@mail.com\u0026#34;), ..user1 }; println!(\u0026#34;{} {}\u0026#34;, user1.active, user1.email); // 不能访问 // println!(\u0026#34;{} {}\u0026#34;, user1, user1.username) 元组结构体：结构体字段没有名字。 fn main() { struct Color(i32, i32, i32); let black = Color(0,0,0); let Color(r, g, b) = black;\t// 模式匹配 println!(\u0026#34;({}, {}, {})\u0026#34;, r, g, b); } 单元结构体：没有字段和属性。如果你定义一个类型，但是不关心该类型的内容, 只关心它的行为时，就可以使用单元结构体： struct Unit; let subject = Unit; // 我们不关心 Unit 的字段数据，只关心它的行为，因此将它声明为单元结构体，然后再为它实现某个特征 impl SomeTrait for Unit { } 使用#[derive(Debug)]打印结构体 默认情况下结构体没有实现Display特征，如果要用{}的方式打印结构体，就需要自己实现Display特征。使用#derive(Debug)可以为结构体实现Debug特征，然后就可以使用{:?}打印结构体。\nfn main() { #[derive(Debug)] struct Color{ r: i32, g: i32, b: i32 } let black = Color{ r: 0, g: 0, b: 0 }; println!(\u0026#34;{:?}\u0026#34;, black); println!(\u0026#34;{:#?}\u0026#34;, black); } 输出结果：\nColor { r: 0, g: 0, b: 0 } Color { r: 0, g: 0, b: 0, } dbg!宏 dbg! 宏会拿走表达式的所有权，然后打印出相应的文件名、行号等 debug 信息，当然还有我们需要的表达式的求值结果。除此之外，它最终还会把表达式值的所有权返回！dbg! 输出到标准错误 stderr，而 println! 输出到标准输出 stdout。\n#[derive(Debug)] struct Rectangle { width: u32, height: u32, } fn main() { let scale = 2; let rect1 = Rectangle { width: dbg!(30 * scale), height: 50, }; dbg!(\u0026amp;rect1); } 输出结果：\n[src\\main.rs:10] 30 * scale = 60 [src\\main.rs:14] \u0026amp;rect1 = Rectangle { width: 60, height: 50, } 枚举 枚举类型是一个类型，它会包含所有可能的枚举成员, 而枚举值是该类型中的具体某个成员的实例。任何类型的数据都可以放入枚举成员中。 #[derive(Debug)] enum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32), } fn show_message(msg: Message) { println!(\u0026#34;{:?}\u0026#34;, msg); } fn main() { let msg1 = Message::Move { x: 1, y: 2 }; let msg2 = Message::ChangeColor(0, 0, 1); println!(\u0026#34;{:?}\u0026#34;, msg1); // Move { x: 1, y: 2 } println!(\u0026#34;{:?}\u0026#34;, msg2); // ChangeColor(0, 0, 1) } 创建枚举时可以用显式的整数指定枚举值，不指定也可以强转为整数 enum Number { Zero = 0, One, Two } fn main() { println!(\u0026#34;{:?} {:?}\u0026#34;, Number::Zero as i32, Number::One as u8) // 0 1 } Option\u0026lt;T\u0026gt;枚举处理值为空的情况 Option\u0026lt;T\u0026gt;定义如下：\nenum Option\u0026lt;T\u0026gt; { Some(T), None, } fn main() { let five = Some(5); let six = plus_one(five); if let Some(n) = six { println!(\u0026#34;{}\u0026#34;, n); } } fn plus_one(x: Option\u0026lt;i32\u0026gt;) -\u0026gt; Option\u0026lt;i32\u0026gt; { match x { None =\u0026gt; None, Some(i) =\u0026gt; Some(i + 1), } } 数组 创建数组 fn main() { let arr = [1,2,3];\t// 自动推导数组类型 let repeat_arr: [i32; 5] = [3;5];\t// 创建包含重复元素的数组 println!(\u0026#34;{:?}\u0026#34;, arr); // [3, 3, 3, 3, 3] } 数组元素为非基本类型 // err,因为 String 没有实现 copy trait let array = [String::from(\u0026#34;rust is good!\u0026#34;); 8]; // 正确写法 let array: [String; 8] = std::array::from_fn(|i| String::from(\u0026#34;hello\u0026#34;)); ","permalink":"https://note-site.pages.dev/posts/rust/rust-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"\u003ch2 id=\"切片\"\u003e切片\u003c/h2\u003e\n\u003cp\u003e切片允许你引用集合中部分连续的元素序列，而不是引用整个集合。切片的长度无法在编译期得知，所以不能直接使用切片类型。\u003cstrong\u003e切片只能使用引用类型\u003c/strong\u003e。切片引用（如无说明，以下均用切片指代切片引用）占用两个字的内存空间，第一个字是指向数据的指针，第二个字是切片的长度。在\u003ccode\u003ex86-64\u003c/code\u003e架构的机器上，一个字是 64 位即 8 字节，所以切片就是 16 字节。\u003c/p\u003e","title":"Rust 数据类型"},{"content":" Command Pattern: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.\n命令模式：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。\n命令模式是一种对象行为型模式，其别名为动作 (Action) 模式或事务 (Transaction) 模式。命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。\n结构 命令模式包含以下 4 个角色：\n（1）Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。\n（2）ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。具体命令类在实现execute()方法时将调用接收者对象的相关操作 (Action) 。\n（3）Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。\n（4）Receiver（接收者）：接收者执行与请求相关的操作，具体实现对请求的业务处理。\n实现 // 抽象命令类 public abstract class Command { public abstract void execute(); } // 调用者 public class Invoker { private Command command; public Invoker(Conmmand command) { this.command = command; } // 业务方法，用于调用命令类的 execute() 方法 public void call() { command.execute(); } } // 具体命令类 public class ConcreteCommand extends Command { private Receiver r;\t// 维持一个对请求接收者对象的引用 public void execute() { r.action();\t// 调用请求接收者的业务处理方法 action() } } // 接收者 public class Receiver { public void action() { // 具体操作 } } 应用实例 为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，例如功能键FunctionButton 可以用于退出系统（由 SystemExitClass 类来实现），也可以用于显示帮助文档（由DisplayHelpClass 类来实现）。用户可以通过修改配置文件改变功能键的用途，现使用命令模式设计该系统，使得功能键类与功能类之间解耦，可为同一个功能键设置不同的功能。\n实例结构图如下：\nFunctionButton 充当请求调用者，SystemExitClass 和 DisplayHelpClass 充当请求接收者，Command 是抽象命令类， ExitCommand 和 HelpCommand 充当具体命令类。\n// 客户端代码 public class Client { public static void main(String args[]) { FunctionButton fb = new FunctionButton(); Command command = (Command) XMLUtils.getBean();\t// 读取配置文件，反射生成对象 fb.setCommand(command);\t// 将命令对象注入功能键 fb.click();\t// 调用功能键业务方法 } } 命令队列和宏命令 有时候，当一个请求发送者发送一个请求时有不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理，此时可以通过命令队列来实现。\n命令队列的实现方法有多种形式，最常用、灵活性最好的一种方式是增加一个 CommandQueue 类，由该类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者。\nclass CommandQueue { private Queue\u0026lt;Command\u0026gt; queue; CommandQueue() { queue = new LinkedList\u0026lt;\u0026gt;(); } void addCommand(Command command) { queue.add(command); } void executeCommands() { while (!queue.isEmpty()) { Command command = queue.poll(); command.execute(); } } } 宏命令 (Macro Command) 又称为组合命令 (Composite Command) ，它是组合模式和命令模式联用的产物。宏命令是一个具体命令类，它拥有一个集合，该集合包含对其他命令对象的引用。通常宏命令不直接与请求接收者交互，而是通过它的成员来调用接收者的方法。当调用宏命令的execute()方法时将递归调用它所包含的每个成员命令的execute()方法， 一个宏命令的成员可以是简单命令，也可以继续是宏命令。执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理。\nclass MacroCommand implements Command { private List\u0026lt;Command\u0026gt; commands; MacroCommand(List\u0026lt;Command\u0026gt; commands) { this.commands = commands; } @Override public void execute() { for (Command command : commands) { command.execute(); } } } 优缺点和适用环境 优点：\n（1）降低系统耦合度。\n（2）新的命令很容易加入到系统中。\n（3）比较容易设计一个命令队列或宏命令\n（4）为请求的撤销 (Undo) 和恢复 (Redo) 提供设计和实现方案\n缺点：\n容易导致系统有过多的命令类。\n适用环境：\n（1）系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。\n（2）系统需要在不同的时间指定请求、将请求排队和执行请求。\n（3）系统需要支持命令的撤销 (Undo) 操作和恢复 (Redo) 操作。\n（4）系统需要将一组操作组合在一起形成宏命令。\n参考 《Java 设计模式》．刘伟．清华大学出版社\n","permalink":"https://note-site.pages.dev/posts/design-pattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/","summary":"\u003cblockquote\u003e\n\u003cp\u003eCommand Pattern: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.\u003c/p\u003e\n\u003cp\u003e命令模式：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。\u003c/p\u003e","title":"命令模式"},{"content":"职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，将请求的发送者和请求的处理者解耦。这就是职责链模式的模式动机。\nChain of Responsibility Pattern: Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.\n职责链模式：避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。\n职责链模式又称为责任链模式，它是一种对象行为型模式。\n结构 职责链模式包含以下两个角色：\n（1）Handler（抽象处理者）：它定义了一个处理的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。每一个处理者的下家还是一个处理者，故在抽象处理者中定义了一个抽象处理者类型的对象作为其对下家的引用，通过该引用处理者可以连成一条链。\n（2）ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中的下一个对象，以便请求的转发。\n实现 抽象处理者：\npublic abstract class Handler { // 维持对下家的引用 public Handler successor; public void setSuccessor(Handler successor) { this.successor = successor; } public abstract void handleRequest(Object request); } 具体处理者：\npublic class ConcreteHandler extends Handler { public void handleRequest(Object request) { if (请求满足条件) { // 处理请求 } else { // 转发请求 this.successor.handleRequest(); } } } 客户端：\nHandler handler1 = new ConcreteHandlerA(); Handler handler2 = new ConcreteHandlerB(); Handler handler3 = new ConcreteHandlerC(); // 创建职责链 handlerl.setSuccessor(handler2); handler2.setSuccessor(handler3); // 发送请求，请求对象通常为自定义类型 handlerl.handleRequest(\u0026#34;请求对象\u0026#34;); 纯的职责链模式 一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个，要么承担全部责任，要么将责任推给下家。不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。\n不纯的职责链模式 在一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收并处理。\n优缺点与适用环境 优点：\n（1）职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，并且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。\n（2）请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象之间的相互连接。\n（3）在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，符合开闭原则。\n缺点：\n对于比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定的影响\n适用环境：\n（1）有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定\n（2）在不明确指定接收者的情况下向多个对象中的一个提交一个请求。\n（3）可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。\n参考 《Java 设计模式》．刘伟．清华大学出版社\n","permalink":"https://note-site.pages.dev/posts/design-pattern/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/","summary":"\u003cp\u003e职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，将请求的发送者和请求的处理者解耦。这就是职责链模式的模式动机。\u003c/p\u003e","title":"职责链模式"},{"content":" Proxy Pattern: Provide a surrogate or placeholder for another object to control access to it.\n代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。\n代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。\n结构 代理模式包含以下 3 个角色：\n（1）Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。\n（2）Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。\n（3）RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。\n实现 // 抽象主题类 public abstract class Subject { public abstract void request(); } // 真实主题类 public class RealSubject extends Subject { public void request() { // 业务方法 } } //代理主题类 public class Proxy extends Subject { private RealSubject realSubject;\t// 维持对真实主题的引用 public void preRequest() { ... } public void postRequest() { ... } public void request() { preRequest(); realSubject.request();\t// 调用真实主题的业务方法 postRequest(); } } 在实际开发过程中，代理类的实现比上述代码要复杂很多，代理模式根据其目的和实现方式不同可分为很多种类，对其中常用的几种代理模式简要说明如下。\n远程代理（Remote Proxy）：为一个位于不同地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为大使 (Ambassador) 。 虚拟代理（Vitural Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 保护代理（Protect Proxy）：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。 智能引用代理（Smart Reference Proxy）：当一个对象被引用时提供一些额外的操作，例如将对象被调用的次数记录下来等。 应用实例 某软件公司承接了某信息咨询公司的收费商务信息查询系统的开发任务，该系统的基本需求如下：\n（1）在进行商务信息查询之前用户需要通过身份验证，只有合法用户才能够使用该查询系统。\n（2）在进行商务信息查询时系统需要记录查询日志，以便根据查询次数收取查询费用。\n该软件公司的开发人员已完成了商务信息查询模块的开发任务，现希望能够以一种松耦合的方式向原有系统增加身份验证和日志记录功能，客户端代码可以无区别地对持原始的商务信息查询模块和增加新功能之后的商务信息查询模块，而且可能在将来还要在该信息查询模块中增加一些新的功能。试使用代理模式设计并实现该收费商务信息查询系统。\n设计结构图：\n远程代理 远程代理 (Remote Proxy) 是一种常用的代理模式，它使得客户端程序可以访问在远程主机上的对象。远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。\n在 Java 语言中可以通过一种名为 RMI (Remote Method Invocation，远程方法调用）的机制来实现远程代理，它能够实现一个 Java 虚拟机中的对象调用另一个 Java 虚拟机中对象的方法。在 RMI 中，客户端对象可以通过一个桩 (Stub) 对象与远程主机上的业务对象进行通信，由于桩对象和远程业务对象接口一致，因此对于客户端而言操作远程对象和本地桩对象没有任何区别，桩对象就是远程业务对象在本地主机的代理对象。\n在 RMI 实现的过程中，远程主机端有一个 Skeleton （骨架）对象来负责与 Stub 对象通信，RMI 的基本实现步骤如下：\n客户端发起请求，将请求转交至 RMI 客户端的 Stub 类。 Stub 类将请求的接口、方法、参数等信息进行序列化。 将序列化后的流使用 Socket 传输至服务器端。 服务器端接收到流后将其转发至相应的 Skeleton 类。 Skeleton 类将请求信息反序列化后调用实际的业务处理类。 业务处理类处理完毕后将结果返回给 Skeleton 类。 Skeleton 类将结果序列化，再次通过 Socket 将流传送给客户端的 Stub 。 Stub 在接收到流后进行反序列化，将反序列化后得到的 Java Object 对象返回给客户端调用者。 至此，一次完整的远程方法调用得以完成。\n虚拟代理 虚拟代理 (Virtual Proxy) 也是一种常用的代理模式，对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后虚拟代理将用户的请求转发给真实对象。\n通常在以下两种情况下可以考虑使用虚拟代理：\n（1）由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象。\n（2）当一个对象的加载十分耗费系统资源的时候也非常适合使用虚拟代理。虚拟代理可以让那些占用大量内存或处理起来非常复杂的对象推迟到使用它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象，再通过代理对象来引用真实对象。\nJava 动态代理 在传统的代理模式中客户端通过 Proxy 类调用 RealSubject 类的request()方法，同时还可以在代理类中封装其他方法（例如preRequest()和postRequest()等）。如果按照这种方法使用代理模式，那么代理类和真实主题类都应该是事先已经存在的，代理类的接口和所代理方法都巳明确指定。每一个代理类在编译之后都会生成一个 class 文件，代理类所实现的接口和所代理的方法都被固定，这种代理被称为静态代理 (Static Proxy) 。如果需要为不同的真实主题类提供代理类或者代理一个真实主题类中的不同方法，都需要增加新的代理类，这将导致系统中的类个数急剧增加，因此需要想办法减少系统中类的个数。\n动态代理 (Dynamic Proxy) 可以让系统在运行时根据实际需要来动态创建代理类，让同一个代理类能够代理多个不同的真实主题类而且可以代理不同的方法。\n从 JDK 1. 3 开始， Java 语言提供了对动态代理的支持，现简要说明如下：\nProxy 类 Proxy 类提供了用于创建动态代理类和实例对象的方法，它是所创建的动态代理类的父类，它最常用的方法如下。\npublic static Class getProxyClass(ClassLoader loader, Class[] interfaces)：该方法用于返回一个 Class 类型的代理类，在参数中需要提供类加载器并需要指定代理的接口数组（与真实主题类的接口列表一致）。\npublic static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)：该方法用于返回一个动态创建的代理类的实例，方法中的第一个参数 loader 表示代理类的类加载器，第二个参数 interfaces 表示代理类所实现的接口列表（与真实主题类的接口列表一致），第三个参数 h 表示所指派的调用处理程序类。\nlnvocationHandler 接口 Invocation Handler 接口是代理处理程序类的实现接口，该接口作为代理实例的调用处理者的公共父类，每一个代理类的实例都可以提供一个相关的具体调用处理者 (lnvocationHandler 接口的子类）。在该接口中声明了如下方法：\npublic Object invoke(Object proxy, Method method, Object[] args)\n该方法用于处理对代理类实例的方法调用并返回相应的结果，当一个代理实例中的业务方法被调用时将自动调用该方法。invoke()方法包含 3 个参数，其中第一个参数 proxy 表示代理类的实例，第二个参数 method 表示需要代理的方法，第三个参数 args 表示代理方法的参数数组。\n动态代理类需要在运行时指定所代理真实主题类的接口，客户端在调用动态代理对象的方法时会将调用请求自动转发给 InvocationHandler 对象的invoke()方法，由invoke()方法来实现对请求的统一处理。\n实例：\n某软件公司要为公司 OA 系统数据访问层 DAO 增加方法调用日志，记录每一个方法被调用的时间和调用结果现使用动态代理进行设计和实现。\n// 抽象主题角色 public interface UserDao { String findById(int id); } // 真实主题角色 public class UserDaoImpl implements UserDao { @Override public String findById(int id) { System.out.println(\u0026#34;查询中...\u0026#34;); return \u0026#34;用户 \u0026#34; + id; } } // 代理主题角色 public class DAOLogHandler implements InvocationHandler { private Object object; public DAOLogHandler() {} // 注入真实主题对象 public DAOLogHandler(Object o) { this.object = o; } // 调用真实主题类中定义的方法 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { beforeInvoke(); Object res = method.invoke(object, args);\t// 转发调用 afterInvoke(); return res; } public void beforeInvoke() { System.out.println(LocalDate.now(ZoneId.of(\u0026#34;Asia/Shanghai\u0026#34;))); } public void afterInvoke() { System.out.println(\u0026#34;方法调用结束\u0026#34;); } } // 客户端 public class Client { public void run() { UserDao userDao = new UserDaoImpl(); InvocationHandler h = new DAOLogHandler(userDao); UserDao proxy = (UserDao) Proxy.newProxyInstance(UserDao.class.getClassLoader(), new Class[]{UserDao.class}, h);\t// 动态创建代理对象 System.out.println(proxy.findById(1)); } } 客户端输出结果如下：\n2023-05-08 查询中... 方法调用结束 用户 1 JDK 中提供的动态代理只能代理一个或多个接口，如果需要动态代理具体类或抽象类，可以使用 CGLib (Code Generation Library) 等工具。\n优缺点和适用环境 优点：\n（1）能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。\n（2）客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码\n缺点：\n（1）由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。\n适用环境：\n（1）当客户端对象需要访问远程主机中的对象时可以使用远程代理。\n（2）当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理。\n（3）当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。\n（4）当需要控制对一个对象的访问为不同用户提供不同级别的访问权限时可以使用保护代理。\n（5）当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。\n参考 《Java 设计模式》．刘伟．清华大学出版社\n","permalink":"https://note-site.pages.dev/posts/design-pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","summary":"\u003cblockquote\u003e\n\u003cp\u003eProxy Pattern: Provide a surrogate or placeholder for another object to control access to it.\u003c/p\u003e\n\u003cp\u003e代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。\u003c/p\u003e","title":"代理模式"},{"content":"Java 中字符串的使用非常普遍，如果每个字符串都用一个对象来表示，会导致系统中有很多重复的字符串，占用较多的内存空间。那么如何避免系统中出现大量相同或相似的对象，同时又不影响客户端程序这些对象进行操作？享元模式正是为解决这一类问题而诞生。享元模式通过共享技术实现相同或相似对象的重用，在逻辑上每一个出现的字符都有一个对象与之对应，然而在物理上它们却共享同一个享元对象，这个对象可以出现在一个字符串的不同地方，相同的字符对象都指向同一个实例，在享元模式中存储这些共享实例对象的地方称为享元池 (Flyweight Pool) 。\n享元对象能做到共享的关键是区分了内部状态 (Intrinsic State) 和外部状态 (Extrinsic State) 。下面将对享元的内部状态和外部状态进行简单的介绍。\n（1）内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。例如字符的内容不会随外部环境的变化而变化，无论在任何环境下字符 “a“ 始终是 “a“ ，都不会变成 “b“ 。\n（2）外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。例如字符的颜色和大小是两个独立的外部状态，它们可以独立变化，相互之间没有影响。\n正因为区分了内部状态和外部状态，可以将具有相同内部状态的对象存储在享元池中，享元池中的对象是可以实现共享的，当需要的时候就将对象从享元池中取出，实现对象的复用。通过向取出的对象注入不同的外部状态可以得到一系列相似的对象，而这些对象在内存中实际上只存储一份。\nFlyweight Pattern: Use sharing to support large numbers of fine-grained objects efficiently.\n享元模式：运用共享技术有效地支持大量细粒度对象的复用。\n享元模式是一种对象结构型模式，又称为轻量级模式，它要求能够被共享的对象必须是细粒度对象。\n结构 享元模式的结构较为复杂，通常结合工厂模式一起使用。它包含了一个享元工厂类。\n享元模式包含以下 4 个角色：\n（1）Flyweight（抽象享元类）：抽象享元类通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。\n（2）ConcreteFlyweight（具体享元类）：具体享元类实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常可以结合单例模式来设计具体享元类为每一个具体享元类提供唯一的享元对象。\n（3）UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体亨元类的对象时可以直接通过实例化创建。\n（4）FlyweightFactory（享元工厂类）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储＂键值对＂的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时．享元工厂提供一个存储在享元池中的实例或者创建一个新的实例（如果不存在），返回新创建的实例并将其存储在享元池中。\n实现 抽象享元类：\npublic abstract class Flyweight { public abstract void operation(String extrinsicState); } 具体享元类：\npublic class ConcreteFlyweight extends Flyweight { // 内部状态 intrinsicState 作为成员变量，同一个享元对象的内部状态是一致的 private String intrinsicState; public ConcreteFlyweight(String intrinsicState) { this.intrinsicState = intrinsicState; } // 外部状态 extrinsicState 在使用时由外部设置，不保存在享元对象中 // 即使是同一个对象，在每一次调用时也可以传入不同的外部状态 public void operation(String extrinsicState) { // 业务方法 } } 非共享具体享元类\npublic class UnsharedConcreteFlyweight extends Flyweight { public void operation(String extrinsicState) { // 业务方法 } } 享元工厂类\npublic class FlyweightFactory { private Map\u0026lt;String, Flyweight\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public Flyweight getFlyweight(String key) { if (map.containsKey(key)) { return map.get(key); } else { Flyweight fw = new ConcreteFlyweight() map.put(key, fw); return fw; } } } 应用实例 某软件公司要开发一个围棋软件，在围棋棋盘中包含大量的黑子和白子，它们的形状、大小一模一样，只是出现的位置不同而已。如果将每一个棋子作为一个独立的对象存储在内存中，将导致该围棋软件在运行时所需的内存空间较大，那么如何降低运行代价、提高系统性能是需要解决的一个问题。为了解决该问题，现使用享元模式来设计该围棋软件的棋子对象。\n该实例结构图如下：\nlgoChessman 充当抽象享元类， BlacklgoChessman 和 WhitelgoChessman 充当具体享元类， IgoChessmanFactory 充当享元工厂类，Coordinate 为外部状态。\nCoordinate：\npublic class Coordinate { int x; int y; public Coordinate(int x, int y) { this.x = x; this.y = y; } } IgoChessman ：\npublic abstract class IgoChessman { public abstract String getColor(); public void display(Coordinate coordinate) { System.out.printf(\u0026#34;%s棋子 (%d, %d)\\n\u0026#34;, getColor(), coordinate.x, coordinate.y); } } 具体享元类：\npublic class WhiteIgoChessman extends IgoChessman { public String getColor() { return \u0026#34;白色\u0026#34;; } } public class BlackIgoChessman extends IgoChessman { public String getColor() { return \u0026#34;黑色\u0026#34;; } } IgoChessmanFactory：\npublic class IgoChessmanFactory { private static final IgoChessmanFactory instance = new IgoChessmanFactory(); private final Map\u0026lt;String, IgoChessman\u0026gt; map;\t// 享元池 public IgoChessmanFactory() { map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;w\u0026#34;, new WhiteIgoChessman()); map.put(\u0026#34;b\u0026#34;, new BlackIgoChessman()); } // 返回享元工厂类的唯一实例 public static IgoChessmanFactory getInstance() { return instance; } // 通过 key 获取具体享元对象 public IgoChessman getIgoChessman(String color) { return map.get(color); } } 客户端：\npublic void test_IgoChessman() { IgoChessmanFactory factory = IgoChessmanFactory.getInstance(); IgoChessman b1 = factory.getIgoChessman(\u0026#34;b\u0026#34;); IgoChessman b2 = factory.getIgoChessman(\u0026#34;b\u0026#34;); IgoChessman w1 = factory.getIgoChessman(\u0026#34;w\u0026#34;); b1.display(new Coordinate(2, 1)); b2.display(new Coordinate(3, 5)); w1.display(new Coordinate(3, 3)); System.out.println(\u0026#34;b1 == b2\\t\u0026#34; + (b1 == b2)); } 输出结果：\n黑色棋子 (2, 1) 黑色棋子 (3, 5) 白色棋子 (3, 3) b1 == b2\ttrue 单纯享元模式 在单纯享元模式中所有的具体享元类都是可以共享的，不存在非共享具体享元类。其结构如图所示：\n复合享元模式 将一些单纯享元对象使用组合模式加以组合还可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。其结构如图所示：\n通过使用复合享元模式可以让复合享元类 CompositConcreteFlyweight 中所包含的每个单纯享元类ConcreteFlyweight 都具有相同的外部状态，而这些单纯享元的内部状态往往可以不同。如果希望为多个内部状态不同的享元对象设置相同的外部状态，可以考虑使用复合享元模式。\n享元模式与 String 类 JDK 类库中的 String 类使用了享元模式。例如\nString a = \u0026#34;abc\u0026#34;; String b = \u0026#34;abc\u0026#34;; System.out.println(a == b);\t// true 优缺点和适用环境 优点：\n（1）享元模式可以减少内存中对象的数量，使得相同或者相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。\n（2）享元模式的外部状态相对独立，而且不会影响其内部状态，从而使享元对象可以在不同的环境中被共享。\n缺点：\n（1）享元模式使系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。\n（2）为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使运行时间变长。\n适用环境：\n（1）一个系统有大量相同或者相似的对象，造成内存的大量耗费。\n（2）对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。\n（3）在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此应当在需要多次重复使用享元对象时才使用享元模式。\n参考 《Java 设计模式》．刘伟．清华大学出版社\n","permalink":"https://note-site.pages.dev/posts/design-pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/","summary":"\u003cp\u003eJava 中字符串的使用非常普遍，如果每个字符串都用一个对象来表示，会导致系统中有很多重复的字符串，占用较多的内存空间。那么如何避免系统中出现大量相同或相似的对象，同时又不影响客户端程序这些对象进行操作？享元模式正是为解决这一类问题而诞生。享元模式通过共享技术实现相同或相似对象的重用，在逻辑上每一个出现的字符都有一个对象与之对应，然而在物理上它们却共享同一个享元对象，这个对象可以出现在一个字符串的不同地方，相同的字符对象都指向同一个实例，在享元模式中存储这些共享实例对象的地方称为享元池 (Flyweight Pool) 。\u003c/p\u003e","title":"享元模式"},{"content":" Facade Pattern: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.\n外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口， 这个接口使得这一子系统更加容易使用。\n外观模式又称为门面模式，它是一种对象结构型模式。在外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。\n结构 外观模式包含 2 个角色：\n（1）Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下它将所有从客户端发来的请求委派到相应的子系统，传递给相应的子系统对象处理。\n（2）SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合； 每一个子系统都可以被客户端直接调用，或者被外观角色调用；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。\n实现 外观模式中所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统。子系统类通常是一些业务类，实现了一些具体的、独立的业务功能。\npublic class SubSystemA { public void methodA(){ // 业务实现 } } public class SubSystemB { public void methodB(){ // 业务实现 } } public class SubSystemC { public void methodC(){ // 业务实现 } } 外观角色：\npublic class Facade { public SubSystemA A = new SubSystemA(); public SubSystemB B = new SubSystemB(); public SubSystemC C = new SubSystemC(); public void method() { A.methodA(); B.methodB(); C.methodC(); } } 客户端：\npublic class Client { public static void main(String args[]) { Facade facade = new Facade(); facade.methon(); } } 实例 某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括 3 个部分，分别是读取源文件、加密、保存加密之后的文件，其中读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这 3 个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这 3 个操作的业务代码封装在 3 个不同的类中。现使用外观模式设计该文件加密模块。\n实现结构图如下：\n抽象外观类 在标准的外观模式结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类对系统进行改进，这在一定程度上可以解决该问题。\n例如：在应用实例 “文件加密模块“ 中更换一个加密类，不再使用原有的基于求模运算的加密类 CipherMachine，而改为基于移位运算的新加密类 NewCipherMachine。在不修改原有外观类的情况下，通过添加新的外观抽象类来实现对子系统对象引用的改变。\n优缺点与适用环境 优点：\n（1）它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目。\n（2）它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。\n（3）一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。\n缺点：\n（1）不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。\n适用环境：\n（1）当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。\n（2）客户端程序与多个子系统之间存在很大的依赖性。\n（3）在层次化结构中可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。\n参考 《Java 设计模式》．刘伟．清华大学出版社\n","permalink":"https://note-site.pages.dev/posts/design-pattern/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/","summary":"\u003cblockquote\u003e\n\u003cp\u003eFacade Pattern: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.\u003c/p\u003e\n\u003cp\u003e外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口， 这个接口使得这一子系统更加容易使用。\u003c/p\u003e","title":"外观模式"},{"content":" Decorator Pattern: Attach additional resposibilies to an object dynamically. Decorators provide a flexible alternative to subclassing for exlending functionality.\n装饰模式：动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。\n装饰模式是一种对象结构型模式， 它以对客户透明的方式动态地给一个对象附加上更多的责任，可以在不需要创建更多子类的情况下让对象的功能得以扩展。\n结构 装饰模式包含以下 4 个角色：\n（1）Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。\n（2）ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰类可以给它增加额外的职责（方法） 。\n（3）Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责， 但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。\n（4）ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法， 并可以增加新的方法用于扩充对象的行为。\n实现 抽象构件类一般设计为抽象类或者接口，在其中声明了抽象业务方法，当然也可以在抽象构件类中实现一些所有具体构件类都共有的业务方法。\n// 抽象构件 public abstract class Component { public abstract void operation(); } // 具体构件 public class ConcreteComponent extends Component { public void operation() { // 基本功能实现 } } // 抽象装饰类 public class Decorator extends Component { private Component c;\t// 维持一个对抽象构件对象的引用 public Decorator(Component c) { this.c = c; } public void operation() { c.operation();\t// 调用原有业务方法 } } 注意：在 Decorator 中并未真正实现operation()方法只是调用原有 component 对象的operation()方法，它没有真正实施装饰，而是提供一个统一的接口，将具体装饰过程交给子类完成。\n// 具体装饰类 public class ConcreteDecorator extends Decorator { public ConcreteDecorator(Component c) { super(c); } public void operation() { super.operation();\t// 调用原有业务方法 addedBehavior();\t// 调用新增业务方法 } // 新增业务方法 public void addedBehavior() { ... } } 在具体装饰类中可以调用到抽象装饰类的operation方法，同时可以定义新的业务方法，例如addedBehavior()。如果不希望该方法被客户端单独调用，可以将其可见性设为私有。\n实例 某软件公司基于面向对象技术开发了一套图形界面构件库 VisualComponent，该构件库提供了大量的基本构件，如窗体、文本框、列表框等，由于在使用该构件库时用户经常要求定制一些特殊的显示效果，如带滚动条的窗体、带黑色边框的文本框、既带滚动条又带黑色边框的列表框等，因此经常需要对该构件库进行扩展以增强其功能。现使用装饰模式来设计该图形界面构件库。\n实现结构图如下：\n透明装饰模式和半透明装饰模式 在标准的装饰模式中新增行为需在原有业务方法中调用，无论是具体构件对象还是装饰过的构件对象，对于客户端而言都是透明的，这种装饰模式被称为透明 (Transparent) 装饰模式。但是在某些情况下，有些新增行为可能需要单独被调用，此时客户端不能再一致性地处理装饰之前的对象和装饰之后的对象，这种装饰模式被称为半透明(Semi-transparent) 装饰模式。\n透明装饰模式 在透明装饰模式中要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。\nComponent c1, c2;\t// 使用抽象构件类型定义对象 c1 = new ConcreteComponent(); c2 = new ConcreteDecorator(c1); c2.operation(); 透明装饰模式可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别，此外还可以对一个已装饰过的对象进行多次装饰。\n半透明装饰模式 为了能够调用新增方法，不得不用具体装饰类型来定义装饰之后的对象，而具体构件类型仍然可以使 用抽象构件类型来定义，这种装饰模式即为半透明装饰模式。\nComponent c1 = new ConcreteComponent();\t// 具体构件可以用抽象构件类型 ConcreteDecorator c2 = new ConcreteDecorator(c1);\t// 必须用具体装饰类型声明 c2.addedBehavior();\t// 单独调用新增业务方法 半透明装饰模式可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便；但是其最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。\n优缺点和适用环境 优点：\n（1）对于扩展一个对象的功能，装饰模式比继承更加灵活．不会导致类的个数急剧增加。\n（2）可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。\n（3）可以对一个对象进行多次装饰。\n（4）具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合开闭原则。\n缺点：\n（1）在使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程度上影响程序的性能。\n（2）更易出错，排错也更困难。\n适用环境：\n（1）在不影响其他对象的情况下以动态、透明的方式给单个对象添加职责。\n（2）当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类．使得子类数目呈爆炸性增长；第二类是因为类被定义为不能被继承。\n参考 《Java 设计模式》．刘伟．清华大学出版社\n","permalink":"https://note-site.pages.dev/posts/design-pattern/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/","summary":"\u003cblockquote\u003e\n\u003cp\u003eDecorator Pattern: Attach additional resposibilies to an object dynamically. Decorators provide a flexible alternative to subclassing for exlending functionality.\u003c/p\u003e\n\u003cp\u003e装饰模式：动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。\u003c/p\u003e","title":"装饰模式"},{"content":" Composite Pattern: Compose object into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.\n组合模式：组合多个对象形成树形结构以表示具有部分－整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。\n组合模式又称为 “部分－整体”（Part-Whole）模式，属于对象结构型模式。它将对象组织到树形结构中，可以用来描述整体与部分的关系。组合模式通过一种巧妙的设计方案使得用户可以一致性地处理整个树形结构或者树形结构的一部分，它描述了如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象，这就是组合模式的模式动机。\n结构 组合模式包含以下 3 个角色：\n（1）Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。\n（2）Leaf（叶子构件）：它在组合结构中表示叶子结点对象，叶子结点没有子结点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法．可以通过抛出异常、提示错误等方式进行处理。\n（3）Composite（容器构件）：它在组合结构中表示容器结点对象，容器结点包含子结点，其子结点可以是叶子结点，也可以是容器结点，它提供一个集合用于存储子结点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子结点的业务方法。\n实现 抽象构件类一般是抽象类或者接口，包含子类共有方法的声明和实现。对于客户端而言，将针对抽象构件编程，而无需关心其具体子类是叶子构件还是容器构件。\n// 抽象构件角色 public abstract class Component { public abstract void add(Component c);\t// 增加成员 public abstract void remove(Component c);\t// 删除成员 public abstract Component getChild(int i);\t// 获取成员 public abstract void operation();\t// 业务方法 } // 叶子构件角色 public class Leaf extends Component { public void add(Component c){ // 抛出异常或者错误提示 } public void remove(Component c){ // 抛出异常或者错误提示 } public Component getChild(int i){ // 抛出异常或者错误提示 } public void operation(){ // 叶子构件具体业务方法实现 } } // 容器构件角色 public class composit extends Component { List\u0026lt;Component\u0026gt; childs = new ArrayList\u0026lt;\u0026gt;(); public void add(Component c){ this.childs.add(c); } public void remove(Component c){ this.childs.remove(c); } public Component getChild(int i){ return this.childs.get(i); } public void operation(){ // 容器构件将递归调用子节点的业务方法 for (Component child : childs) { child.operation(); } } } 容器构件和叶子构件可以有多个，定义不同的实现。\n透明组合模式 组合模式根据抽象构件类的定义形式义可以分为透明组合模式和安全组合模式。\n透明组合模式中，抽象构件 Component 声明了所有用于管理成员对象的方法，包括add()、remove()以及getChild()方法，这样做的好处是确保所有的构件类都有相同的接口。在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象。\n透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对象不可能包含成员对象，因此为其提供add()、remove()以及getChild()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码） 。\n安全组合模式 在安全组合模式中抽象构件 Component 中没有声明任何用于管理成员对象的方法，而是在 Composite 类中声明并实现这些方法。\n安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。在实际应用中，安全组合模式的使用频率也非常高。\n优缺点和适用环境 优点：\n（1）可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次。它让客户端忽略了层次的差异，方便对整个层次结构进行控制。\n（2）客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。\n（3）在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合开闭原则。\n（4）为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合可以形成复杂的树形结构，而对树形结构的控制却非常简单。\n缺点：\n在增加新构件时很难对容器中的构件类型进行限制。有时候希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，在使用组合模式时不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下必须通过在运行时进行类型检查来实现，实现较为复杂。\n适用环境：\n（1）在具有整体和部分的层次结构中希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。\n（2）在一个使用而向对象语言开发的系统中需要处理一个树形结构。\n（3）在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。\n参考 《Java 设计模式》．刘伟．清华大学出版社\n","permalink":"https://note-site.pages.dev/posts/design-pattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/","summary":"\u003cblockquote\u003e\n\u003cp\u003eComposite Pattern: Compose object into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.\u003c/p\u003e\n\u003cp\u003e组合模式：组合多个对象形成树形结构以表示具有部分－整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。\u003c/p\u003e","title":"组合模式"},{"content":"Scoop 是一个 Windows 下的命令行安装程序，它可以帮助用户轻松地安装、卸载和管理命令行工具和应用程序。Scoop 的设计理念是使得软件的安装和管理过程更加简单、快速和可靠。\n环境要求 PowerShell 5（或更高版本） .NET Framework 4.5（或更高版本） 安装 以管理员身份打开 PowerShell\n设置允许 PowerShell 执行本地脚本 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 修改 Scoop 安装路径 Scoop 默认安装在 C:\\Users\\用户名\\scoop ，其全局安装的软件在 C:\\ProgramData\\scoop。修改默认路径需要提前设置环境变量：\n或者通过命令行设置环境变量：\n# Scoop 安装路径 [Environment]::SetEnvironmentVariable(\u0026#39;SCOOP\u0026#39;, \u0026#39;D:\\Dependency\\Scoop\u0026#39;, \u0026#39;User\u0026#39;) # Scoop 全局安装路径，需要以管理员身份运行 [Environment]::SetEnvironmentVariable(\u0026#39;SCOOP_GLOBAL\u0026#39;, \u0026#39;D:\\Dependency\\Scoop\\Global\u0026#39;, \u0026#39;Machine\u0026#39;) 安装 Scoop iwr -useb get.scoop.sh | iex 安装 Aria2 安装 Aria2 后 Scoop 会自动调用 Aria2 实现多线程下载。\nscoop install aria2 使用 scoop config 指令可以配置 Aria2 参数，以下是与 Aria2 相关的配置项：\naria2-enabled: 开启 Aria2 下载，默认true aria2-retry-wait: 重试等待秒数，默认2 aria2-split: 单任务最大连接数，默认5 aria2-max-connection-per-server: 单服务器最大连接数，默认5 ，最大16 aria2-min-split-size: 最小文件分片大小，默认5M 推荐配置：\nscoop config aria2-split 32 scoop config aria2-max-connection-per-server 16 scoop config aria2-min-split-size 1M 安装 sudo Scoop 全局安装软件的时候需要管理员权限，安装 sudo 后，我们就可以在 scoop 命令前加 sudo 来提权以简化步骤。\nscoop install sudo 修复并检查潜在问题 scoop install 7zip scoop install innounp scoop install dark sudo Set-ItemProperty \u0026#39;HKLM:\\SYSTEM\\CurrentControlSet\\Control\\FileSystem\u0026#39; -Name \u0026#39;LongPathsEnabled\u0026#39; -Value 1 scoop checkup scoop install # 安装软件 scoop install [-k|g] \u0026lt;app\u0026gt; # -k: 禁用缓存 # -g: 全局安装，需要管理员权限 scoop uninstall # 卸载软件 scoop uninstall [-g|p] \u0026lt;app\u0026gt; # -g: 卸载全局安装软件，需要管理员权限 # -p: 同时删除配置文件 scoop update # 更新软件 scoop update [-g|k] \u0026lt;软件名\u0026gt; # 更新 Scoop 和所有已安装的软件 scoop update [-g|k] * # -k: 禁用缓存 # -g: 全局 scoop bucket bucket 即 Scoop 中的软件仓库，默认软件仓库 main。相关命令：\n# 添加软件仓库 scoop bucket add \u0026lt;仓库名\u0026gt; \u0026lt;仓库地址\u0026gt; # 列出已添加的软件仓库 scoop bucket list # 删除软件仓库 scoop bucket rm \u0026lt;仓库名\u0026gt; 可以通过 scoop bucket known 查看官方支持的 bucket。\n$ scoop bucket known main extras\t# 包含不太符合主存储桶标准的应用 versions\t# 包含一些知名软件包的旧版本的 Bucket nirsoft\tsysinternals php nerd-fonts\t# 用于安装 Nerd Fonts 字体的 Bucket nonportable java\t# 包含不同版本开源 JDK games 对于官方支持的 bucket 可以直接添加。推荐添加 extras 仓库。\nscoop bucket add extras 添加 nerd-fonts 仓库后可以通过以下命令搜索到所有的字体：\nscoop search \u0026#34;-NF\u0026#34; 安装字体需要使用管理员权限：\nsudo scoop install FiraCode-NF 对于第三方 bucket：\n# 添加第三方 bucket scoop bucket add \u0026lt;bucketname\u0026gt; https://github.com/xxx/xxx # 从第三方 bucket 中安装软件 scoop install \u0026lt;bucketname\u0026gt;/\u0026lt;app\u0026gt; scoop cache 默认情况下，Scoop 安装软件会缓存应用的安装包。使用 scoop cache 命令来清理。\nscoop cache show：显示安装包缓存 scoop cache rm \u0026lt;app\u0026gt;：删除指定应用的安装包缓存 scoop cache rm *：删除所有的安装包缓存 scoop cleanup Scoop 默认保留软件的旧版本，更新软件后通过 scoop cleanup 命令来清理。\nscoop cleanup [-k] \u0026lt;app\u0026gt;：删除指定软件的旧版本。-k 表示删除缓存 scoop cleanup *：删除所有软件的旧版本 其他 # 列出已安装的软件 scoop list # 查找软件 scoop search \u0026lt;app\u0026gt; # 显示软件信息 scoop info \u0026lt;app\u0026gt; # 检查 Scoop 潜在问题并给出建议 scoop checkup # 查看命令帮助说明 scoop help \u0026lt;command\u0026gt; 代理 Scoop 默认使用的是系统代理，可以通过 scoop config 指定代理。需要注意只支持 http 协议。\n# 设置代理 scoop config proxy localhost:1080 #查看代理 scoop config proxy # 取消代理 scoop config rm proxy 常用命令 # 更新 scoop 及软件包列表 scoop update ## 安装软件 ## # 非全局安装（并禁止安装包缓存） scoop install -k \u0026lt;app\u0026gt; # 全局安装（并禁止安装包缓存） sudo scoop install -gk \u0026lt;app\u0026gt; ## 卸载软件 ## # 卸载非全局软件（并删除配置文件） scoop uninstall -p \u0026lt;app\u0026gt; # 卸载全局软件（并删除配置文件） sudo scoop uninstall -gp \u0026lt;app\u0026gt; ## 更新软件 ## # 更新所有非全局软件（并禁止安装包缓存） scoop update -k * # 更新所有软件（并禁止安装包缓存） sudo scoop update -gk * ## 垃圾清理 ## # 删除所有旧版本非全局软件（并删除软件包缓存） scoop cleanup -k * # 删除所有旧版本软件（并删除软件包缓存） sudo scoop cleanup -gk * # 清除软件包缓存 scoop cache rm * 参考 [1] Scoop - 最好用的 Windows 包管理器\n[2] 使用 Scoop 管理 Windows 下的软件和开发环境\n","permalink":"https://note-site.pages.dev/posts/windows/scoop/","summary":"\u003cp\u003eScoop 是一个 Windows 下的命令行安装程序，它可以帮助用户轻松地安装、卸载和管理命令行工具和应用程序。Scoop 的设计理念是使得软件的安装和管理过程更加简单、快速和可靠。\u003c/p\u003e","title":"Windows 下的包管理器：Scoop"},{"content":" Bridge Pattern: Decouple an abstraction from its implementation so that the two can vary independently.\n桥接模式：将抽象部分与它的实现部分解耦，使得两者都能够独立变化。\n桥接模式是一种结构型设计模式，它将抽象与实现解耦，使得两者可以独立地变化。这种模式涉及到一个抽象类，它将实现类的对象作为一个成员变量，并通过构造函数或者 setter 方法将实现类的对象传递给抽象类。这样，抽象类可以在运行时调用实现类的方法，而不需要知道具体的实现细节。\n结构 桥接模式包含以下 4 个角色：\n（1）Abstraction（抽象类）：它是用于定义抽象类的接口，通常是抽象类而不是接口，其中定义了一个 Implementor（实现类接口）类型的对象并可以维护该对象，它与 Implementor 之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。\n（2）RefinedAbstraction（扩充抽象类）：它扩充由 Abstraction 定义的接口，通常情况下它不再是抽象类而是具体类，实现了在 Abstraction 中声明的抽象业务方法，在 RefinedAbstraction 中可以调用在Implementor 中定义的业务方法。\n（3）Implementor（实现类接口）：它是定义实现类的接口，这个接口可以和 Abstraction 的接口完全不同。一般而言， Implementor 接口仅提供基本操作，而 Abstraction 定义的接口可能会做更多更复杂的操作。Implementor 接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在 Abstraction中不仅拥有自己的方法，还可以调用 Implementor 中定义的方法，使用关联关系来替代继承关系。\n（4）Concretelmplementor（具体实现类）：它具体实现了 Implementor 接口，在不同的Concretelmplementor 中提供基本操作的不同实现，在程序运行时 Concretelmplementor 对象将替换其父类对象，提供给抽象类具体的业务操作方法。\n实现 使用桥接模式时首先应该识别出一个类所具有的两个独立变化的维度，将它们设计为两个独立的继承等级结构，为两个维度都提供抽象层，并建立抽象耦合。\npublic interface Implementor { public void operationImpl(); } public class ConcreteImplementor implements Implementor { public void operationImpl() { //\t具体业务方法实现 } } public abstract class Abstraction { protected Implementor impl;\t// 定义实现类接口对象 public Abstraction(Implementor impl) { this.impl = impl; } public abstract void operation();\t// 声明抽象业务方法 } public class RefineAbstraction extends Abstraction { public void operation() { // 业务方法 impl.operationImpl(); // 业务方法 } } 桥接模式分为两个维度：Abstraction 和 Implementor，两者都是独立的继承体系，通过在 Abstraction 中注入 Implementor 对象的组合方式实现关联。Abstraction 的维度变化通过继承实现，而 Implementor 的维度变化通过接口实现。\n桥接模式与适配器模式的联用 适配器模式通常用于现有系统与第三方产品功能的集成，采用增加适配器的方式将第三方类集成到系统中。桥接模式则不同，用户可以通过接口继承或类继承的方式对系统进行扩展。桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时可以采用适配器模式。\n例如：在某系统的报表处理模块中需要将报表显示和数据输出分开，系统可以有多种报表显示方式也可以有多种数据输出方式，例如可以将数据输出为文本文件，也可以输出为 Excel文件。如果需要输出为 Excel 文件，则需要调用与 Excel 相关的 API，而这个 API 是现有系统所不具备的，该 API 由厂商提供。因此可以同时使用适配器模式和桥接模式来设计该模块、如图 10- 6 所示。\n优缺点和适用环境 优点：\n（1）分离抽象接口及其实现部分。桥接模式使用 “对象间的关联关系” 解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。\n（2）很多情况下，桥接模式可以替代多层继承方案。\n（3）桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度都不需要修改原有系统，符合开闭原则。\n缺点：\n（1）桥接模式的使用会增加系统的理解与设计难度。\n（2）桥接模式要求正确地识别出系统中的两个独立变化的维度， 因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。\n适用环境：\n（1）如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系， 通过桥接模式可以使它们在抽象层建立一个关联关系。\n（2）一个类存在两个（或多个）独立变化的维度，且这两个（或多个） 维度都需要独立进行扩展。\n（3）对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。\n参考 《Java 设计模式》．刘伟．清华大学出版社\n","permalink":"https://note-site.pages.dev/posts/design-pattern/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/","summary":"\u003cblockquote\u003e\n\u003cp\u003eBridge Pattern: Decouple an abstraction from its implementation so that the two can vary independently.\u003c/p\u003e\n\u003cp\u003e桥接模式：将抽象部分与它的实现部分解耦，使得两者都能够独立变化。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e桥接模式是一种结构型设计模式，它将抽象与实现解耦，使得两者可以独立地变化。这种模式涉及到一个抽象类，它将实现类的对象作为一个成员变量，并通过构造函数或者 setter 方法将实现类的对象传递给抽象类。这样，抽象类可以在运行时调用实现类的方法，而不需要知道具体的实现细节。\u003c/p\u003e","title":"桥接模式"},{"content":"git add # 添加工作区一个或多个文件的修改到暂存区 git add [filename | pattern] # 将所有修改加入暂存区 git add . # 撤回文件 git rm --cached [file] git commit # 提交暂存区内容到本地仓库的当前分支 git commit -m \u0026#39;注释内容\u0026#39; git log git log [option] # --all: 显示所有分支 # --(pretty=)oneline: 将提交信息显示为一行 # --graph: 以图的形式显示 多屏显示控制方式：空格向下翻页，b 向上翻页，q 退出\ngit diff 将工作区文件与其它版本文件比较，默认和暂存区比较\ngit diff [版本] [文件] git checkout 切换 # 切换分支 git checkout \u0026lt;branch\u0026gt; # 例如：切换到名为 develop 的分支 git checkout develop\t# 创建并切换分支 git checkout -b \u0026lt;new-branch\u0026gt; # 例如：创建并切换到 feature 分支 git checkout -b feature\t# 切换到指定的提交。commit 可以是提交哈希值或者分支名称 git checkout \u0026lt;commit\u0026gt; # 例如：切换到哈希值为 a1b2c3d4 的提交 git checkout a1b2c3d4 # 切换到指定的标签 git checkout \u0026lt;tag\u0026gt; # 例如：切换到 v1.0.0 标签 git checkout v1.0.0 # 将指定的文件恢复到上一次提交的状态 git checkout -- \u0026lt;file\u0026gt; # 例如：将 index.html 文件恢复到上一次提交的状态（放弃修改） git checkout -- index.html # 将指定分支中的文件复制到当前分支中 git checkout \u0026lt;branch\u0026gt; -- \u0026lt;file\u0026gt; # 例如：将 feature 分支中的 index.html 文件复制到当前分支中 git checkout feature -- index.html git branch 分支管理 # 列出本地所有分支，当前分支前面会有一个星号 (*) git branch [-a|v|r] [--merged] [--no-merged] # -a: 列出本地和远程仓库的所有分支 # -v: verbose 信息 # -r: 列出远程仓库的所有分支 # --merged: 列出已经被合并的分支 # --no-merged: 列出还未被合并的分支 # 创建本地分支 git branch \u0026lt;name\u0026gt; # 删除分支 git branch -d \u0026lt;branch\u0026gt;\t# 分支必须先被合并到其他分支才能被删除 git branch -D \u0026lt;branch\u0026gt;\t# 强制删除 # 重命名分支 git branch -m \u0026lt;new-name\u0026gt; # 将 branch 分支指向指定的 commit git branch -f \u0026lt;branch\u0026gt; \u0026lt;commit\u0026gt; # 设置本地分支跟踪远程分支 git branch --set-upstream-to=\u0026lt;remote\u0026gt;/\u0026lt;branch\u0026gt; git merge 合并 # 将名为 \u0026lt;branch\u0026gt; 的分支合并到当前分支 git merge \u0026lt;branch\u0026gt; # 执行不快进合并，将 \u0026lt;branch\u0026gt; 分支合并到当前分支，同时创建一个新的合并提交 git merge --no-ff \u0026lt;branch\u0026gt; # 将指定的提交合并到当前分支 git merge \u0026lt;commit\u0026gt; # 将指定的提交合并到当前分支 git merge --abort git remote 远程仓库 # 添加远程仓库，默认远端名称 origin git remote add \u0026lt;name\u0026gt; \u0026lt;url\u0026gt; git remote [remove|rename] \u0026lt;name\u0026gt; #查看远程仓库 git remote -v\tgit push, clone, fetch, pull # push git push [-f] [--set--upstream] \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; # -f: 强制覆盖 # --set--upstream: 推送到远端的同时建立和远端分支的联系。 # 从远程 Git 仓库克隆代码，会自动设置一个名为 origin 的远程仓库 git clone \u0026lt;url\u0026gt; # 不指定远端名称和分支名，则抓取所有分支 git fetch [-p] \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; # -p: 修剪操作，比如删除不存在的远程分支引用 # 拉取 git pull \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; Git fetch 和 Git pull 的区别如下：\nGit fetch 命令只会将远程仓库的变化拉取到本地仓库，不会自动将变化合并到当前工作分支。相反，Git pull 命令会拉取远程仓库的变化，并将其合并到当前工作分支。因此，Git pull 命令可以看作是 Git fetch 和 Git merge 两个命令的组合。 Git fetch 命令可以让你检查远程仓库的变化，以便在合并之前对其进行审查。Git pull 命令会直接将远程仓库的变化合并到当前工作分支，这可能会导致冲突，因此需要在合并之前仔细检查。 git tag 标签管理 git tag 命令用于给 Git 仓库中的某个提交打标签，可以理解为 Git 版本库的快照。通过给某个重要的提交打上一个有意义的标记，以便在后续查找和管理。\nGit 中的标签分为两种：\n轻量标签（lightweight tag）：指向某个提交的引用，没有附加信息，它只是指向该提交的指针 附注标签（annotated tag）：一个独立的 Git 对象，它有自己的校验和，包含标签名称、标签创建者、标签日期、标签注释等附加信息 # 创建一个轻量标签 git tag v1.0.0 # 创建一个附注标签 git tag -a v1.0.0 -m \u0026#34;First version released\u0026#34; 123b45b1 # 查看标签信息 git show \u0026lt;tag\u0026gt; # 或者 git tag -v \u0026lt;tag\u0026gt; # 推送所有标签 git push origin --tags # 推送指定标签 git push origin \u0026lt;tag\u0026gt; # 删除指定标签 git tag -d \u0026lt;tag\u0026gt; #删除远程仓库指定标签 git push origin :refs/tags/\u0026lt;tag\u0026gt; # 获取指定标签 git fetch origin \u0026lt;tag\u0026gt; git reset 回退 git reset \u0026lt;option\u0026gt; \u0026lt;commit\u0026gt; # 参数： # --sort：仅在本地库移动 HEAD 指针 # --mixed：在本地库移动 HEAD 指针，重置暂存区(默认值) # --hard：在本地库移动 HEAD 指针，重置暂存区，重置工作区 git reset --hard HEAD\\^\\^：后退两个版本 git reset --hard HEAD~2：后退两个版本 git revert 撤销 git revert 命令可以用于撤销一个或多个提交，同时创建一个新的提交来保存撤销操作，这样可以 保留 原有的提交 历史记录，并在之后的开发中进行修改和调整。用法\ngit revert \u0026lt;commit\u0026gt; # 同时撤销多个提交 git revert \u0026lt;commit1\u0026gt; \u0026lt;commit2\u0026gt; ... # 撤销最近的提交 git revert HEAD # 撤销某一段提交 git revert \u0026lt;start\u0026gt;..\u0026lt;end\u0026gt; git rebase 重放 git rebase 是 Git 命令中的一个常用命令，用于将一个分支的修改合并到另一个分支中。与 git merge 命令不同，git rebase 命令会将本地未提交的修改「移动」到目标分支的最新提交之上。\n# 将当前分支的修改“移动”到 \u0026lt;branch\u0026gt; 分支的最新提交之上 git rebase \u0026lt;branch\u0026gt; # 以交互模式（interactive mode）执行 rebase，可以让开发者自定义合并策略 git rebase -i \u0026lt;commit\u0026gt; # 例如： git rebase -i HEAD~3 # 在解决完冲突后继续执行 rebase 操作 git rebase --continue # 取消当前的 rebase 操作，并回到 rebase 操作之前的状态 git rebase --abort git stash 贮藏 假如现在我们在某个分支做了一些工作（但是还没完成，暂时不能 push），这时候这个分支急需进行操作（比如 rebase）。\ngit stash 命令用于将工作区中的修改暂时贮藏起来，以便稍后恢复。这在需要切换分支或者打补丁时非常有用，用法：\n# 保存当前工作目录中的修改，并添加一条描述信息，以便在后续的工作中更好地区分每个 stash。 git stash save \u0026#34;message\u0026#34; # 列出所有已保存的贮藏操作 git stash list # 查看指定 stash 的详细信息 git stash show stash@{n} # 将指定 stash 中的修改应用到当前分支上，并将这些修改从 stash 中删除。 git stash apply stash@{n} # 将最新的 stash 中的修改应用到当前分支上，并将这些修改从 stash 中删除 git stash pop # 放弃（删除）指定 stash 中的修改 git stash drop stash@{n} # 清空所有的 stash git stash clear 注意 恢复 stash 贮藏操作，如果与当前工作目录暂存区的修改冲突，也要先修改冲突才能再进行 stash 的相关操作。\ngit cherry-pick 挑选提交 我们知道，Git 的每次提交（commit）都会生成一个唯一的哈希值。git cherry-pick 命令可以将某个提交的更改应用到当前分支中（而无需将整个分支合并过来），并自动生成一个新的提交，这个新的提交包含了指定提交的更改，用法：\ngit cherry-pick \u0026lt;commit\u0026gt; 注意 git cherry-pick 会自动解决冲突。\ngit reflog 回溯 用于查看本地仓库历史操作记录\ngit reflog 参考 Git 版本控制学习笔记（二）\n","permalink":"https://note-site.pages.dev/posts/miscellaneous/git-%E6%8C%87%E4%BB%A4/","summary":"\u003ch2 id=\"git-add\"\u003egit add\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 添加工作区一个或多个文件的修改到暂存区\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit add \u003cspan class=\"o\"\u003e[\u003c/span\u003efilename \u003cspan class=\"p\"\u003e|\u003c/span\u003e pattern\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 将所有修改加入暂存区\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit add .\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 撤回文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit rm --cached \u003cspan class=\"o\"\u003e[\u003c/span\u003efile\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"git-commit\"\u003egit commit\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 提交暂存区内容到本地仓库的当前分支\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit commit -m \u003cspan class=\"s1\"\u003e\u0026#39;注释内容\u0026#39;\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"git-log\"\u003egit log\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit log \u003cspan class=\"o\"\u003e[\u003c/span\u003eoption\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# --all: 显示所有分支\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# --(pretty=)oneline: 将提交信息显示为一行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# --graph: 以图的形式显示\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e多屏显示控制方式：空格向下翻页，b 向上翻页，q 退出\u003c/p\u003e","title":"Git 指令"},{"content":" Singleton Pattern: Ensure a class has only one instance, and provide a global point of access to it.\n单例模式：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。\n优缺点和使用场景 单例模式的优点主要如下：\n（1）单例模式提供了对唯一实例的受控访问。 因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。\n（2）由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。\n（3）允许可变数目的实例。基于单例模式可以进行扩展，使用与控制单例对象相似的 方法来获得指定个数的实例对象．既节省系统资源．义解决了由于单例对象共享过多有损性能的问题。（注：自行提供指定数目实例对象的类可称为多例类）\n单例模式的缺点主要如下：\n（1）由千单例模式中没有抽象层．因此单例类的扩展有很大的困难。\n（2）单例类的职责过重，在一定程度上违背了单一职责原则。 因为单例类既提供了业务方法．又提供了创建对象的方法（工厂方法），将对象的创建和对象本身的功能耦合在一起。\n在以下情况下可以考虑使用单例模式：\n（1）系统中需要一个唯一的全局对象，如配置管理类、数据库连接池等。\n（2）系统只需要一个实例对象或者因为资源消耗太大而只允许创建一个对象。\n实现方法 1. 饿汉式（静态常量） public class Singleton { private static final Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 优点：在类加载时初始化，通过类加载机制实现线程安全。\n缺点：触发类加载的原因有多种，可能无法在调用getInstance()方法时才进行类加载，进而无法实现懒加载。如果实例长时间不使用，可能造成资源浪费。\n2. 懒汉式（线程不安全） public class Singleton { private static Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 3. 懒汉式（线程安全，同步方法） public class Singleton { private static Singleton instance; private Singleton() {} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 优点：第一次调用才进行初始化，避免内存浪费\n缺点：需要加锁才能保证单例，但加锁会影响效率\n4. 双重检查（Double Check Lock，DCL） public class Singleton { // 注意要用volatile修饰阻止指令重排序 private static volatile Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 优点：相比懒汉式只会在实例不存在时加锁，提高了效率。\n缺点：第一次加载稍慢，也由于 Java 内存模型的原因偶尔会失败。在高并发环境也有一定的缺陷，虽然发生的概率很小。\n5. IoDH（静态内部类） public class Singleton { private Singleton() {} private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return SingletonHolder.INSTANCE; } } 优点：在调用getInstance()方法时才进行加载，达到了懒汉式的效果，并且是线程安全的。\n缺点：写法复杂\n6. 枚举 public enum Singleton { INSTANCE; public void doSomething() { // ... } } 优点：实现简单，枚举本身就是单例模式，并且是线程安全的。由 JVM 从根本上提供保障，避免通过反射和序列化的方式破环单例。\n缺点：无延迟加载，不适合创建大量单例对象的场景。\n参考 [1] GPT-4\n","permalink":"https://note-site.pages.dev/posts/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","summary":"\u003cblockquote\u003e\n\u003cp\u003eSingleton Pattern: Ensure a class has only one instance, and provide a global point of access to it.\u003c/p\u003e\n\u003cp\u003e单例模式：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"优缺点和使用场景\"\u003e优缺点和使用场景\u003c/h2\u003e\n\u003cp\u003e单例模式的优点主要如下：\u003c/p\u003e\n\u003cp\u003e（1）单例模式提供了对唯一实例的受控访问。 因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。\u003c/p\u003e","title":"单例模式"},{"content":" Prototype Pattern: Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.\n原型模式：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。\n原型模式是一种创建型设计模式，它允许使用者通过复制现有对象来创建新的对象。这种模式既可以避免直接创建对象开销大，又可以提高系统性能。\n实现 import java.util.HashMap; import java.util.Map; // 抽象原型 interface Prototype { Prototype clone(); } // 具体原型1 class ConcretePrototype1 implements Prototype { @Override public Prototype clone() { return new ConcretePrototype1(); } } // 具体原型2 class ConcretePrototype2 implements Prototype { @Override public Prototype clone() { return new ConcretePrototype2(); } } // 原型管理器 class ProtoManager { private static Map\u0026lt;String, Prototype\u0026gt; PROTOTYPES = new HashMap\u0026lt;\u0026gt;(); static { PROTOTYPES.put(\u0026#34;concretePrototype1\u0026#34;, new ConcretePrototype1()); PROTOTYPES.put(\u0026#34;concretePrototype2\u0026#34;, new ConcretePrototype2()); } public static Prototype getPrototype(String type) { return PROTOTYPES.get(type).clone(); } } public class Demo { public static void main(String[] args) { Prototype prototype1 = ProtoManager.getPrototype(\u0026#34;concretePrototype1\u0026#34;); Prototype prototype2 = ProtoManager.getPrototype(\u0026#34;concretePrototype2\u0026#34;); System.out.println(prototype1.getClass()); // class ConcretePrototype1 System.out.println(prototype2.getClass()); // class ConcretePrototype2 } } 适用环境 在以下情况下可以考虑使用原型模式：\n（1）创建新对象成本较大（例如初始化需要占用较长的时间、占用太多的CPU资源或网络资源），新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改。\n（2）系统要保存对象的状态，而对象的状态变化很小。\n（3）需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。\n参考 《Java 设计模式》．刘伟．清华大学出版社\n","permalink":"https://note-site.pages.dev/posts/design-pattern/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","summary":"\u003cblockquote\u003e\n\u003cp\u003ePrototype Pattern: Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.\u003c/p\u003e\n\u003cp\u003e原型模式：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e原型模式是一种创建型设计模式，它允许使用者通过复制现有对象来创建新的对象。这种模式既可以避免直接创建对象开销大，又可以提高系统性能。\u003c/p\u003e","title":"原型模式"},{"content":"Viper 是一个用于 Go 语言开发的配置处理库，它可以处理几乎所有格式的配置。Viper 支持：\n设置默认值 读取 JSON、TOML、YAML、HCL、.env 和 .properties 配置文件 从环境变量、命令行和 io.Reader 读取配置 从远程配置中心（例如 Consul）读取配置并监听修改 监听配置文件修改和自动重新加载配置 快速使用 安装：\n$ go get github.com/spf13/viper 使用：\nfunc TestViper(t *testing.T) { viper.SetConfigName(\u0026#34;config\u0026#34;) viper.SetConfigType(\u0026#34;toml\u0026#34;) viper.AddConfigPath(\u0026#34;./\u0026#34;) viper.SetDefault(\u0026#34;mysql.host\u0026#34;, \u0026#34;localhost\u0026#34;) viper.SetDefault(\u0026#34;mysql.port\u0026#34;, 3306) if err := viper.ReadInConfig(); err != nil { fmt.Println(\u0026#34;read config error\u0026#34;) return } fmt.Printf(\u0026#34;version:\\t%v\\n\u0026#34;, viper.GetString(\u0026#34;app_name\u0026#34;)) fmt.Printf(\u0026#34;app_name:\\t%v\\n\u0026#34;, viper.GetString(\u0026#34;version\u0026#34;)) fmt.Printf(\u0026#34;date:\\t\\t%v\\n\u0026#34;, viper.GetString(\u0026#34;datetime\u0026#34;)) fmt.Printf(\u0026#34;readonly:\\t%v\\n\u0026#34;, viper.GetBool(\u0026#34;readonly\u0026#34;)) } 配置文件 config.toml 如下\napp_name = \u0026#34;daily-lib\u0026#34; version = \u0026#39;1.1.2\u0026#39; datetime = 2023-04-30T18:16:33 readonly = true [mysql] host = \u0026#34;127.0.0.1\u0026#34; user = \u0026#34;root\u0026#34; password = \u0026#34;123456\u0026#34; timeout = \u0026#34;3s\u0026#34; [server] protocols = [\u0026#34;http\u0026#34;, \u0026#34;https\u0026#34;, \u0026#34;websocket\u0026#34;] viper 使用需要设置文件名（SetConfigName）、设置文件类型（setConfigType）和搜索路径（AddConfigPath），然后调用 ReadInConfig 即可。\n运行结果（已省略测试相关信息）\nversion:\tdaily-lib app_name:\t1.1.2 date:\t2023-04-30T18:16:33 readonly:\ttrue 有几点需要注意：\n设置文件名时不要带后缀； 搜索路径可以设置多个，viper 会根据设置顺序依次查找； viper 获取值时使用 section.key 的形式，即传入嵌套的键名； 默认值可以通过 SetDefault 方法设置。 读取键值 Get(key string) interface{} 方法：根据名称返回键值，返回值是接口类型 GetType(key string) Type：可以返回 Type 类型的值，Type 可以是 Bool/Float64/Int/String/Time/Duration/IntSlice/StringSlice。但是请注意，如果指定的键不存在或类型不正确，GetType方法返回对应类型的零值。 判断键是否存在可以使用 isSet 方法。另外，GetStringMap 和 GetStringMapString 直接以 map 返回某个键下面所有的键值对，前者返回 map[string]interface{}，后者返回map[string]string。 AllSettings 以 map[string]interface{} 的形式返回所有键值对。\nfmt.Println(\u0026#34;timeout:\u0026#34;, viper.GetDuration(\u0026#34;mysql.timeout\u0026#34;)) fmt.Println(\u0026#34;server protocols:\u0026#34;, viper.GetStringSlice(\u0026#34;server.protocols\u0026#34;)) fmt.Println(\u0026#34;mysql host exist:\u0026#34;, viper.IsSet(\u0026#34;mysql.port\u0026#34;)) fmt.Println(\u0026#34;mysql:\u0026#34;, viper.GetStringMapString(\u0026#34;mysql\u0026#34;)) fmt.Println(\u0026#34;all settings:\u0026#34;, viper.AllSettings()) 运行结果：\ntimeout: 3s server protocols: [http https websocket] mysql host exist: true mysql: map[host:127.0.0.1 password:123456 timeout:3s user:root] all settings: map[app_name:daily-lib date:2023-04-30 mysql:map[host:127.0.0.1 password:123456 port:3306 timeout:3s user:root] readonly:true server:map[protocols:[http https websocket]] version:1.1.2] 对于 getDuration 方法，只要是 time.ParseDuration 接受的格式都可以\n设置键值 viper 支持在多个地方设置，使用下面的顺序依次读取：\n调用Set显示设置的； 命令行选项； 环境变量； 配置文件； 默认值。 viper.Set 如果某个键通过viper.Set设置了值，那么这个值的优先级最高。\nviper.Set(\u0026#34;redis.port\u0026#34;, 5381) 如果将上面这行代码放到程序中，运行程序，输出的redis.port将是 5381。\n命令行选项 如果一个键没有通过viper.Set显示设置值，那么获取时将尝试从命令行选项中读取。 如果有，优先使用。viper 使用 pflag 库来解析选项。 我们首先在init方法中定义选项，并且调用viper.BindPFlags绑定选项到配置中：\nfunc init() { pflag.Int(\u0026#34;redis.port\u0026#34;, 8381, \u0026#34;Redis port to connect\u0026#34;) // 绑定命令行 viper.BindPFlags(pflag.CommandLine) } 然后，在main方法开头处调用pflag.Parse解析选项。\n编译、运行程序：\n$ ./main.exe --redis.port 9381 redis port: 9381 如果不传入选项：\n$ ./main.exe redis port: 7381 注意，这里并不会使用选项redis.port的默认值。\n但是，如果通过下面的方法都无法获得键值，那么返回选项默认值（如果有）。试试注释掉配置文件中redis.port看看效果。\n环境变量 如果前面都没有获取到键值，将尝试从环境变量中读取。我们既可以一个个绑定，也可以自动全部绑定。\n在init方法中调用AutomaticEnv方法绑定全部环境变量：\nfunc init() { // 绑定环境变量 viper.AutomaticEnv() } 创建一个名为redis.port的环境变量，值为 10381。 运行程序，输出的redis.port值为 10381。\n也可以单独绑定环境变量：\nfunc init() { // 绑定环境变量 viper.BindEnv(\u0026#34;redis.port\u0026#34;) viper.BindEnv(\u0026#34;go.path\u0026#34;, \u0026#34;GOPATH\u0026#34;) } func main() { // 省略部分代码 fmt.Println(\u0026#34;go path: \u0026#34;, viper.Get(\u0026#34;go.path\u0026#34;)) } 调用BindEnv方法，如果只传入一个参数，则这个参数既表示键名，又表示环境变量名。 如果传入两个参数，则第一个参数表示键名，第二个参数表示环境变量名。\n还可以通过viper.SetEnvPrefix方法设置环境变量前缀，这样一来，通过AutomaticEnv和一个参数的BindEnv绑定的环境变量， 在使用Get的时候，viper 会自动加上这个前缀再从环境变量中查找。\n如果对应的环境变量不存在，viper 会自动将键名全部转为大写再查找一次。所以，使用键名gopath也能读取环境变量GOPATH的值。\n配置文件 如果经过前面的途径都没能找到该键，viper 接下来会尝试从配置文件中查找。 为了避免环境变量的影响，需要删除redis.port这个环境变量。\n看 快速使用 中的示例。\n默认值 在上面的 快速使用 一节，我们已经看到了如何设置默认值，这里就不赘述了。\n读取配置 从 io.Reader 中读取 viper 支持从 io.Reader 中读取配置。这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流。\nfunc main() { viper.SetConfigType(\u0026#34;toml\u0026#34;) tomlConfig := []byte(` app_name = \u0026#34;awesome web\u0026#34; [mysql] ip = \u0026#34;127.0.0.1\u0026#34; port = 3306 user = \u0026#34;dj\u0026#34; password = 123456 `) err := viper.ReadConfig(bytes.NewBuffer(tomlConfig)) if err != nil { log.Fatal(\u0026#34;read config failed: %v\u0026#34;, err) } fmt.Println(\u0026#34;redis port: \u0026#34;, viper.GetInt(\u0026#34;redis.port\u0026#34;)) } Unmarshal viper 支持将配置 Unmarshal 到一个结构体中，为结构体中的对应字段赋值。\ntype Config struct { AppName string LogLevel string MySQL MySQLConfig Redis RedisConfig } type MySQLConfig struct { IP string Port int User string Password string Database string } type RedisConfig struct { IP string Port int } func main() { viper.SetConfigName(\u0026#34;config\u0026#34;) viper.SetConfigType(\u0026#34;toml\u0026#34;) viper.AddConfigPath(\u0026#34;.\u0026#34;) err := viper.ReadInConfig() if err != nil { log.Fatal(\u0026#34;read config failed: %v\u0026#34;, err) } var c Config viper.Unmarshal(\u0026amp;c) fmt.Println(c.MySQL) } 输出结果：\n{127.0.0.1 3306 dj 123456 awesome} 保存配置 有时候，我们想要将程序中生成的配置，或者所做的修改保存下来。viper 提供了接口！\nWriteConfig：将当前的 viper 配置写到预定义路径，如果没有预定义路径，返回错误。将会覆盖当前配置； SafeWriteConfig：与上面功能一样，但是如果配置文件存在，则不覆盖； WriteConfigAs：保存配置到指定路径，如果文件存在，则覆盖； SafeWriteConfig：与上面功能一样，但是入股配置文件存在，则不覆盖。 下面我们通过程序生成一个config.toml配置：\nfunc main() { viper.SetConfigName(\u0026#34;config\u0026#34;) viper.SetConfigType(\u0026#34;toml\u0026#34;) viper.AddConfigPath(\u0026#34;.\u0026#34;) viper.Set(\u0026#34;log_level\u0026#34;, \u0026#34;DEBUG\u0026#34;) viper.Set(\u0026#34;mysql.ip\u0026#34;, \u0026#34;127.0.0.1\u0026#34;) viper.Set(\u0026#34;mysql.port\u0026#34;, 3306) viper.Set(\u0026#34;mysql.user\u0026#34;, \u0026#34;root\u0026#34;) viper.Set(\u0026#34;mysql.password\u0026#34;, \u0026#34;123456\u0026#34;) err := viper.SafeWriteConfig() if err != nil { log.Fatal(\u0026#34;write config failed: \u0026#34;, err) } } 运行后生成的配置文件如下：\nlog_level = \u0026#34;DEBUG\u0026#34; [mysql] ip = \u0026#34;127.0.0.1\u0026#34; password = \u0026#34;123456\u0026#34; port = 3306 user = \u0026#34;root\u0026#34; 监听文件修改 viper 可以监听文件修改，热加载配置。因此不需要重启服务器，就能让配置生效。\nfunc main() { viper.SetConfigName(\u0026#34;config\u0026#34;) viper.SetConfigType(\u0026#34;toml\u0026#34;) viper.AddConfigPath(\u0026#34;.\u0026#34;) err := viper.ReadInConfig() if err != nil { log.Fatal(\u0026#34;read config failed: %v\u0026#34;, err) } viper.WatchConfig() fmt.Println(\u0026#34;redis port before sleep: \u0026#34;, viper.Get(\u0026#34;redis.port\u0026#34;)) time.Sleep(time.Second * 10) fmt.Println(\u0026#34;redis port after sleep: \u0026#34;, viper.Get(\u0026#34;redis.port\u0026#34;)) } 只需要调用viper.WatchConfig，viper 会自动监听配置修改。如果有修改，重新加载的配置。\n上面程序中，我们先打印redis.port的值，然后Sleep 10s。在这期间修改配置中redis.port的值，Sleep结束后再次打印。 发现打印出修改后的值：\nredis port before sleep: 7381 redis port after sleep: 73810 另外，还可以为配置修改增加一个回调：\nviper.OnConfigChange(func(e fsnotify.Event) { fmt.Printf(\u0026#34;Config file:%s Op:%s\\n\u0026#34;, e.Name, e.Op) }) 这样文件修改时会执行这个回调。\nviper 使用 fsnotify 这个库来实现监听文件修改的功能。\n来源 Go 每日一库之 viper\n","permalink":"https://note-site.pages.dev/posts/go/lib/viper/","summary":"\u003cp\u003eViper 是一个用于 Go 语言开发的配置处理库，它可以处理几乎所有格式的配置。Viper 支持：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e设置默认值\u003c/li\u003e\n\u003cli\u003e读取 JSON、TOML、YAML、HCL、.env 和 .properties 配置文件\u003c/li\u003e\n\u003cli\u003e从环境变量、命令行和 \u003ccode\u003eio.Reader\u003c/code\u003e 读取配置\u003c/li\u003e\n\u003cli\u003e从远程配置中心（例如 Consul）读取配置并监听修改\u003c/li\u003e\n\u003cli\u003e监听配置文件修改和自动重新加载配置\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"快速使用\"\u003e快速使用\u003c/h2\u003e\n\u003cp\u003e安装：\u003c/p\u003e","title":"Viper"},{"content":"Spring 接口限流是指在高并发场景下，对接口进行限制访问次数的一种技术手段。通过限制接口的访问速度和频率，可以保护系统不受到突发流量的冲击，防止系统崩溃或者性能下降。\n常见的限流算法有：固定时间窗口算法、滑动时间窗口算法、令牌桶算法、漏桶算法等等。这些限流算法都有一个共同点，即通过一定的规则来控制接口被访问的速度和频率，以达到保护系统稳定运行的目的。\n原生实现 固定时间窗口算法 固定窗口算法是最基础的限流算法之一，它将时间分成若干个固定的时间窗口，在每个时间窗口内限制请求的数量。这种算法实现简单，但容易出现流量突发的情况。下面是一个示例：\npublic class FixedTimeWindowLimiter { private final int limit; // 时间窗口内允许通过的请求数 private final long windowSize; // 时间窗口大小，单位为毫秒 private final LinkedList\u0026lt;Long\u0026gt; timestamps = new LinkedList\u0026lt;\u0026gt;(); // 请求时间戳队列 public FixedTimeWindowLimiter(int limit, long windowSize) { this.limit = limit; this.windowSize = windowSize; } /** * 判断当前请求是否允许通过 */ public synchronized boolean tryAcquire() { long currentTimestamp = System.currentTimeMillis(); if (timestamps.size() \u0026gt;= limit) { // 如果请求数已达到限制数量 long oldestTimestamp = timestamps.getFirst(); if (currentTimestamp - oldestTimestamp \u0026lt; windowSize) { // 如果最早的请求还在时间窗口内 return false; // 拒绝本次请求 } timestamps.removeFirst(); // 移除最早的请求时间戳 } timestamps.addLast(currentTimestamp); // 添加当前请求时间戳 return true; // 允许本次请求通过 } } 在上面的代码中，我们定义了一个 FixedTimeWindowLimiter 类，用于实现固定时间窗口限流的功能。在该类中，我们定义了 limit 和 windowSize 两个属性，分别表示时间窗口内允许通过的请求数和时间窗口大小。通过 timestamps 队列来保存请求的时间戳，当请求次数超过阈值时，判断最早的请求是否在时间窗口内，如果是则拒绝本次请求，否则移除最早的请求时间戳，并添加当前请求时间戳。\n接下来，在需要进行限流的接口方法中调用 FixedTimeWindowLimiter 的 tryAcquire 方法即可实现固定时间窗口限流的功能，例如：\nprivate static final FixedTimeWindowLimiter LIMITER = new FixedTimeWindowLimiter(10, 1000); @GetMapping(\u0026#34;/hello\u0026#34;) public String hello() { if (LIMITER.tryAcquire()) { return \u0026#34;Hello World!\u0026#34;; } else { return \u0026#34;Too many requests\u0026#34;; } } 滑动时间窗口算法 滑动时间窗口限流是一种更加细粒度的限流算法，其原理是将单位时间划分为若干个时间窗口，并在每个时间窗口内都设置一定的请求次数阈值。下面是一个示例：\npublic class SlidingTimeWindowLimiter { private final int limit; // 每个时间窗口内允许通过的请求数 private final long windowSize; // 时间窗口大小，单位为毫秒 private final LinkedList\u0026lt;Long\u0026gt; timestamps = new LinkedList\u0026lt;\u0026gt;(); // 请求时间戳队列 public SlidingTimeWindowLimiter(int limit, long windowSize) { this.limit = limit; this.windowSize = windowSize; } /** * 判断当前请求是否允许通过 */ public synchronized boolean tryAcquire() { long currentTimestamp = System.currentTimeMillis(); timestamps.addLast(currentTimestamp); // 添加当前请求时间戳 removeObsoleteTimestamps(currentTimestamp); // 移除过期的请求时间戳 return timestamps.size() \u0026lt;= limit; // 判断请求数是否超过限制数量 } /** * 移除过期的请求时间戳 */ private void removeObsoleteTimestamps(long currentTimestamp) { long earliestTimestamp = currentTimestamp - windowSize; while (!timestamps.isEmpty() \u0026amp;\u0026amp; timestamps.getFirst() \u0026lt; earliestTimestamp) { timestamps.removeFirst(); } } } 在上面的代码中，我们定义了一个 SlidingTimeWindowLimiter 类，用于实现滑动时间窗口限流的功能。在该类中，我们定义了 limit 和 windowSize 两个属性，分别表示每个时间窗口内允许通过的请求数和时间窗口大小。通过 timestamps 队列来保存请求的时间戳，在每个时间窗口内移除过期的请求时间戳，并判断请求数是否超过限制数量。\n接下来，在需要进行限流的接口方法中调用 SlidingTimeWindowLimiter 的 tryAcquire 方法即可实现滑动时间窗口限流的功能，例如：\nprivate static final SlidingTimeWindowLimiter LIMITER = new SlidingTimeWindowLimiter(10, 1000); @GetMapping(\u0026#34;/hello\u0026#34;) public String hello() { if (LIMITER.tryAcquire()) { return \u0026#34;Hello World!\u0026#34;; } else { return \u0026#34;Too many requests\u0026#34;; } } 令牌桶算法 令牌桶算法是一种比较常见的限流算法，它维护了一个固定容量的令牌桶来限制请求的速率。在令牌桶中，每个请求需要消耗一个或多个令牌才能被放行，请求速率超过令牌桶容量时，请求就会被阻塞。下面是一个示例：\npublic class TokenBucketLimiter { private final int capacity; // 令牌桶最大容量 private final double rate; // 每秒钟产生的令牌数 private double tokens; // 当前令牌数 private long lastRefillTime; // 上次添加令牌的时间 public TokenBucketLimiter(int capacity, double rate) { this.capacity = capacity; this.rate = rate; this.tokens = capacity; // 初始化令牌桶为满状态 this.lastRefillTime = System.currentTimeMillis(); // 初始化上次添加令牌的时间为当前时间 } /** * 判断当前请求是否允许通过 */ public synchronized boolean tryAcquire() { refill(); // 先尝试添加令牌 if (tokens \u0026gt;= 1) { // 如果有令牌，则减少令牌数 tokens -= 1; return true; // 允许本次请求通过 } else { return false; // 拒绝本次请求 } } /** * 添加令牌 */ private void refill() { long now = System.currentTimeMillis(); double elapsedTime = (now - lastRefillTime) / 1000.0; // 计算距离上次添加令牌的时间 tokens = Math.min(capacity, tokens + elapsedTime * rate); // 添加令牌，不能超过最大容量 lastRefillTime = now; // 更新上次添加令牌的时间 } } 在上面的代码中，我们定义了一个 TokenBucketLimiter 类，用于实现令牌桶限流的功能。在该类中，我们定义了 capacity 和 rate 两个属性，分别表示令牌桶的最大容量和每秒钟产生的令牌数。通过 tokens 记录当前令牌数以及 lastRefillTime 记录上次添加令牌的时间，在每次调用 tryAcquire 方法时先尝试添加令牌，再判断是否有足够的令牌处理本次请求。\n接下来，在需要进行限流的接口方法中调用 TokenBucketLimiter 的 tryAcquire 方法即可实现令牌桶限流的功能。\n漏桶算法 漏桶算法是另一种限流算法，它通过维护一个固定容量的漏桶来限制请求的速率。在漏桶中，请求会被放入漏桶中并以固定的速率流出，当漏桶已满时，新的请求会被丢弃或排队等待。漏桶算法相比令牌桶算法更适合于限制恶意攻击行为。\nimport java.util.concurrent.atomic.AtomicInteger; public class LeakyBucket { private int capacity; // 桶的容量 private int rate; // 流出速率（每秒钟流出多少个请求） private AtomicInteger water = new AtomicInteger(0); // 当前桶中的水量 private long lastLeakTime = System.currentTimeMillis(); // 上次流出时间 public LeakyBucket(int capacity, int rate) { this.capacity = capacity; this.rate = rate; } // 尝试流出一个请求，返回是否成功 public synchronized boolean tryRelease() { long now = System.currentTimeMillis(); int gap = (int) ((now - lastLeakTime) / 1000) * rate; int available = Math.max(0, water.get() - gap); if (available \u0026lt; capacity) { water.incrementAndGet(); lastLeakTime = now; return true; } else { return false; } } } 在上面的代码中，LeakyBucket 类表示漏桶。它有两个属性 capacity 和 rate，分别表示桶的容量和流出速率。另外还有一个原子整数 water 表示当前桶中的水量，以及一个长整型变量 lastLeakTime 用于记录上次流出时间。\n在 tryRelease 方法中，我们首先计算出从上次流出到现在一共可以流出多少个请求，即 gap 值。然后通过 water 原子整数获取当前桶中的水量 available。如果 available 小于容量，则表示可以流出一个请求，因此我们将 water 的值加 1，并更新 lastLeakTime。如果 available 大于等于容量，则不能流出请求，返回 false。\n使用漏桶算法限流时，我们需要创建一个 LeakyBucket 对象并在每个请求到达时调用其 tryRelease 方法来判断是否限流。如果返回 false，则表示请求被限制。\n框架实现 在 spring 中，实现接口限流的方法有以下几种：\n基于 AOP 实现\n使用 Redis 实现\n借助第三方组件如 Hystrix、guava、Resilience4j 等\nAOP 实现 首先，定义一个注解 @RateLimit，用于标记需要进行限流的方法：\n@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface RateLimit { int value() default 10; // 默认每秒钟最多处理 10 个请求 } 接着，我们可以定义一个切面类 RateLimitInterceptor，使用令牌桶算法实现限流逻辑：\n@Component @Aspect public class RateLimitInterceptor { private Map\u0026lt;String, LeakyBucket\u0026gt; buckets = new ConcurrentHashMap\u0026lt;\u0026gt;(); @Around(\u0026#34;@annotation(rateLimit)\u0026#34;) public Object limit(ProceedingJoinPoint joinPoint, RateLimit rateLimit) throws Throwable { String key = joinPoint.getSignature().toLongString(); LeakyBucket bucket = buckets.computeIfAbsent(key, k -\u0026gt; new LeakyBucket(rateLimit.value(), rateLimit.value())); if (bucket.tryRelease()) { return joinPoint.proceed(); } else { throw new RuntimeException(\u0026#34;Too many requests\u0026#34;); } } private static class LeakyBucket { private final int capacity; private final int rate; private volatile int water = 0; private volatile long lastLeakTime = System.nanoTime(); public LeakyBucket(int capacity, int rate) { this.capacity = capacity; this.rate = rate; } public boolean tryRelease() { long now = System.nanoTime(); int gap = (int) TimeUnit.MILLISECONDS.toSeconds(now - lastLeakTime) * rate; int available = Math.max(0, water - gap); if (available \u0026lt; capacity) { water++; lastLeakTime = now; return true; } else { return false; } } } } 在上面的代码中，我们定义了一个 RateLimitInterceptor 类，并使用 @Aspect 注解标记它为一个切面。在 limit 方法中，我们首先从当前方法的签名获取唯一键值，然后使用 ConcurrentHashMap 缓存每个方法对应的漏桶。如果漏桶允许请求通过，则调用原始方法并返回结果；否则直接抛出异常。\n最后，我们需要在 Spring Boot 应用程序类上添加 @EnableAspectJAutoProxy 注解启用切面自动代理。\n现在，只要在需要限流的方法上添加 @RateLimit 注解即可实现接口限流。例如：\n@RestController public class MyController { @GetMapping(\u0026#34;/hello\u0026#34;) @RateLimit(value = 5) public String hello() { return \u0026#34;Hello world\u0026#34;; } } Redis 实现 首先，定义一个注解 @RateLimit，用于标记需要进行限流的方法。注解定义和基于 AOP 实现中的一致。接着，我们可以定义一个切面类 RateLimitInterceptor，使用不同框架实现限流逻辑：\n使用 spring-data-redis 框架 @Component @Aspect public class RateLimitInterceptor { @Autowired private StringRedisTemplate redisTemplate; @Around(\u0026#34;@annotation(rateLimit)\u0026#34;) public Object limit(ProceedingJoinPoint joinPoint, RateLimit rateLimit) throws Throwable { String methodName = joinPoint.getSignature().toLongString(); String key = \u0026#34;rate_limit:\u0026#34; + methodName; Long count = redisTemplate.opsForValue().increment(key, 1); if (count == 1) { redisTemplate.expire(key, 1, TimeUnit.SECONDS); } if (count \u0026gt; rateLimit.value()) { throw new RuntimeException(\u0026#34;Too many requests\u0026#34;); } else { return joinPoint.proceed(); } } } 在上面的代码中，我们使用 StringRedisTemplate 类访问 Redis 存储。在 limit 方法中，我们首先根据当前方法签名生成一个唯一键值，并将其作为 Redis 的 key 值。然后，我们使用 Redis 的自增操作递增这个 key 对应的计数器，并设置过期时间为 1 秒钟。如果计数器的值超过了限流阈值，则抛出异常；否则调用原始方法并返回结果。\n使用 Redisson 框架 @Component @Aspect @RequiredArgsConstructor public class RateLimitInterceptor { private final RedissonClient redissonClient; @Around(\u0026#34;@annotation(rateLimit)\u0026#34;) public Object limit(ProceedingJoinPoint joinPoint, RateLimit rateLimit) throws Throwable { String methodName = joinPoint.getSignature().toLongString(); RRateLimiter limiter = redissonClient.getRateLimiter(methodName); limiter.trySetRate(RateType.OVERALL, rateLimit.value(), 1, RateIntervalUnit.SECONDS); if (limiter.tryAcquire()) { return joinPoint.proceed(); } else { throw new RuntimeException(\u0026#34;Too many requests\u0026#34;); } } } 在上面的代码中，我们使用 RedissonClient 类访问 Redis 存储，并从中获取一个 RateLimiter 对象。在 limit 方法中，我们首先根据当前方法签名生成一个唯一键值，并将其作为 Redisson 的 key 值。然后，我们使用 trySetRate() 方法设置该限流器的速率，并使用 tryAcquire() 方法尝试获取令牌。如果获取令牌成功，则调用原始方法并返回结果；否则抛出异常。\nGuava 实现 Guava 是 Google 开源的一款 Java 工具库，其中包含了 RateLimiter 类，可以用于实现限流功能。通过创建一个全局的 RateLimiter 对象，并在接口方法中调用 acquire 方法进行令牌桶的获取，即可实现限流。例如：\nprivate static final RateLimiter LIMITER = RateLimiter.create(10.0); @GetMapping(\u0026#34;/hello\u0026#34;) public String hello() { if (LIMITER.tryAcquire()) { return \u0026#34;Hello World!\u0026#34;; } else { return \u0026#34;Too many requests\u0026#34;; } } Resilience4j 实现 Resilience4j 是一个轻量级的容错框架，可以用于实现各种模式，如熔断、限流、重试等。\n添加 Resilience4j 依赖项 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.resilience4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;resilience4j-spring-boot3\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置接口限流 resilience4j: ratelimiter: instances: myRateLimiter: limitForPeriod: 10 limitRefreshPeriod: 1s timeoutDuration: 500ms 在此示例中，我们将每秒允许的最大请求次数设置为 10，并使用 limitRefreshPeriod 属性设置刷新周期为 1 秒。timeoutDuration 属性设置等待令牌的超时时间。\n添加@RateLimiter注释。在接口实现方法上添加@RateLimiter注释并指定 Resilience4j 限流器的名称 @GetMapping(\u0026#34;/hello\u0026#34;) @RateLimiter(name = \u0026#34;myRateLimiter\u0026#34;) public String hello() { return \u0026#34;Hello World!\u0026#34;; } 在此示例中，我们使用 @RateLimiter 注解将 hello() 方法标记为受 myRateLimiter 限制。\nspring-cloud-gateway 实现 Spring Cloud Gateway 自带的限流实际上是通过 redis 实现的，其实现方式在 spring-cloud-gateway-server/META-INF/scripts/request_rate_limiter.lua。\nspring-cloud-gateway 有两种配置方式，第一种是通过配置文件，下面是一个示例：\n# application.yml spring: cloud: gateway: routes: - id: my_route uri: https://example.org filters: - name: RequestRateLimiter args: key-resolver: \u0026#34;#{@ipKeyResolver}\u0026#34; redis-rate-limiter.replenishRate: 1 # 令牌填充速度(个/s) redis-rate-limiter.burstCapacity: 2 # 令牌桶的大小 redis-rate-limiter.requestedTokens: 1 # 每次请求获取令牌个数 其中，key-resolver 使用 SpEL 表达式 #{@beanName} 从 Spring 容器中获取 hostAddrKeyResolver 对象。它的实现如下：\n@Configuration public class KeyResolveConfiguration { // 根据访问 ip 限流 @Bean(name = \u0026#34;ipKeyResolver\u0026#34;) public KeyResolver ipKeyResolver() { return exchange -\u0026gt; Mono.just(Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getHostName()); } } 第二种方式是通过下面的代码来配置：\n@Bean public RouteLocator myRoutes(RouteLocatorBuilder builder) { return builder.routes() .route(p -\u0026gt; p .path(\u0026#34;/service/**\u0026#34;) .filters(filter -\u0026gt; filter.requestRateLimiter() .rateLimiter(RedisRateLimiter.class, rl -\u0026gt; rl .setBurstCapacity(3) .setReplenishRate(1) .setRequestedTokens(1)) .and()) .uri(\u0026#34;lb://service\u0026#34;)) .build(); } 这样就可以对某个 route 进行限流了。但是这里有一点要注意，replenishRate 不支持设置小数，也就是说往桶中填充的 token 的速度最少为每秒 1 个，所以，如果限流规则是每分钟 10 个请求（按理说应该每 6 秒填充一次，或每秒填充 1/6 个 token），这种情况 Spring Cloud Gateway 就没法正确的限流。\n参考 Spring Cloud Gateway 之限流篇\nChatGPT 3.5\n","permalink":"https://note-site.pages.dev/posts/miscellaneous/spring-%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81/","summary":"\u003cp\u003eSpring 接口限流是指在高并发场景下，对接口进行限制访问次数的一种技术手段。通过限制接口的访问速度和频率，可以保护系统不受到突发流量的冲击，防止系统崩溃或者性能下降。\u003c/p\u003e","title":"Spring 接口限流"},{"content":"homedir 是一个不借助 cgo 获取用户目录的 go 库。\n使用 go 内置的 os/user 也可以获取用户目录，但是在 Darwin 系统中需要使用 cgo，这意味着任何使用了 os/user 的 go 代码都不能交叉编译。但是大多数时候使用 os/user 都只是为了获取用户目录。\n使用 安装：\n$ go get github.com/mitchellh/go-homedir 示例：\nfunc TestDir(t *testing.T) { dir, err := homedir.Dir() expand, err := homedir.Expand(\u0026#34;~/example/path\u0026#34;) if err != nil { fmt.Println(err) return } fmt.Println(dir)\t// C:\\Users\\用户名 fmt.Println(expand)\t// C:\\Users\\用户名\\example\\path } homedir 的使用非常简单，只有两个函数：Dir() 用于获取用户目录，Expand(path string) 用于将 ~ 转换为用户目录。\n默认情况下 homedir 开启了缓存功能，获取到用户目录后会缓存到属性中，即使运行过程中修改了用户目录也会返回之前的内容。可以通过将 DisableCache 属性设置为 true 来关闭缓存，也可以通过 Reset() 方法重置缓存。\n原理 homedir 库只有一个 homedir.go 文件，其属性和主要方法如下：\nvar DisableCache bool var homedirCache string var cacheLock sync.RWMutex func Dir() (string, error) func Expand(path string) (string, error) func Reset() 排除缓存代码后，Dir() 方法关键实现代码如下：\nif runtime.GOOS == \u0026#34;windows\u0026#34; { result, err = dirWindows() } else { // Unix-like system, so just assume Unix result, err = dirUnix() } 根据系统类型调用不同方法。\ndirWindows() 方法：\nfunc dirWindows() (string, error) { // First prefer the HOME environmental variable if home := os.Getenv(\u0026#34;HOME\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } // Prefer standard environment variable USERPROFILE if home := os.Getenv(\u0026#34;USERPROFILE\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } drive := os.Getenv(\u0026#34;HOMEDRIVE\u0026#34;) path := os.Getenv(\u0026#34;HOMEPATH\u0026#34;) home := drive + path if drive == \u0026#34;\u0026#34; || path == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;HOMEDRIVE, HOMEPATH, or USERPROFILE are blank\u0026#34;) } return home, nil } 依次从 HOME、USERPROFILE 获取，否则将 HOMEDRIVE 和 HOMEPATH 拼接。\ndirUnix() 方法：\nfunc dirUnix() (string, error) { homeEnv := \u0026#34;HOME\u0026#34; if runtime.GOOS == \u0026#34;plan9\u0026#34; { // On plan9, env vars are lowercase. homeEnv = \u0026#34;home\u0026#34; } // First prefer the HOME environmental variable if home := os.Getenv(homeEnv); home != \u0026#34;\u0026#34; { return home, nil } var stdout bytes.Buffer // If that fails, try OS specific commands if runtime.GOOS == \u0026#34;darwin\u0026#34; { cmd := exec.Command(\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, `dscl -q . -read /Users/\u0026#34;$(whoami)\u0026#34; NFSHomeDirectory | sed \u0026#39;s/^[^ ]*: //\u0026#39;`) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err == nil { result := strings.TrimSpace(stdout.String()) if result != \u0026#34;\u0026#34; { return result, nil } } } else { cmd := exec.Command(\u0026#34;getent\u0026#34;, \u0026#34;passwd\u0026#34;, strconv.Itoa(os.Getuid())) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err != nil { // If the error is ErrNotFound, we ignore it. Otherwise, return it. if err != exec.ErrNotFound { return \u0026#34;\u0026#34;, err } } else { if passwd := strings.TrimSpace(stdout.String()); passwd != \u0026#34;\u0026#34; { // username:password:uid:gid:gecos:home:shell passwdParts := strings.SplitN(passwd, \u0026#34;:\u0026#34;, 7) if len(passwdParts) \u0026gt; 5 { return passwdParts[5], nil } } } } // If all else fails, try the shell stdout.Reset() cmd := exec.Command(\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;cd \u0026amp;\u0026amp; pwd\u0026#34;) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err != nil { return \u0026#34;\u0026#34;, err } result := strings.TrimSpace(stdout.String()) if result == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;blank output when reading home directory\u0026#34;) } return result, nil } 尝试获取 HOME 变量（在 plan9 系统中是 home）\nMac 系统下使用指令 dscl -q . -read /Users/\u0026quot;$(whoami)\u0026quot; NFSHomeDirectory | sed 's/^[^ ]*: //' 获取\ngetent 命令可以用来查看系统数据库中的相关记录，通过getent passwd [key] 查询当前用户的信息，其中就包含了用户目录\n如果以上命令都失败了，因为 cd 命令不加参数可以回到用户目录，所以可以通过cd \u0026amp;\u0026amp; pwd 返回用户目录。\n","permalink":"https://note-site.pages.dev/posts/go/lib/homedir/","summary":"\u003cp\u003ehomedir 是一个不借助 cgo 获取用户目录的 go 库。\u003c/p\u003e\n\u003cp\u003e使用 go 内置的 \u003ccode\u003eos/user\u003c/code\u003e 也可以获取用户目录，但是在 Darwin 系统中需要使用 cgo，这意味着任何使用了 \u003ccode\u003eos/user\u003c/code\u003e 的 go 代码都不能交叉编译。但是大多数时候使用 \u003ccode\u003eos/user\u003c/code\u003e 都只是为了获取用户目录。\u003c/p\u003e","title":"Homedir"},{"content":"colly 是用 Go 语言编写的功能强大的爬虫框架。它提供简洁的 API，拥有强劲的性能，可以自动处理 cookie\u0026amp;session，还有提供灵活的扩展机制。\n快速使用 安装 colly 库：\n$ go get -u github.com/gocolly/colly/v2 示例：爬取百度首页左上角链接\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/gocolly/colly/v2\u0026#34; \u0026#34;testing\u0026#34; ) func TestCrawl(t *testing.T) { c := colly.NewCollector( colly.AllowedDomains(\u0026#34;www.baidu.com\u0026#34;), ) c.OnHTML(\u0026#34;#s-top-left a\u0026#34;, func(e *colly.HTMLElement) { fmt.Println(e.Text) }) c.Visit(\u0026#34;https://www.baidu.com/\u0026#34;) } colly 使用流程：\n调用 colly.newCollector() 创建一个类型为 *colly.Collector 的爬虫对象。由于每隔网页都有很多指向其它网页的链接。如果不加限制的话，运行可能永远不会停止。所以上面通过传入一个选项 colly.AllowedDomains(\u0026quot;www.baidu.com\u0026quot;) 限制只爬取域名为 www.baidu.com 的网页\n调用 c.onHTML(goquerySelector string, f HTMLCallback) 方法注册回调函数，第一个参数是类似 JQuery 的选择器，对于选择器匹配的每个元素都会执行函数 f。\n调用 c.Visit() 访问第一个页面\ncolly 爬取到页面之后，会使用 goquery 解析这个页面。然后查找注册的 HTML 回调对应元素选择器（element-selector），将 goquery.Selection 封装成一个 colly.HTMLElement 执行回调。\ncolly.HTMLElement 其实就是对 goquery.Selection 的简单封装：\ntype HTMLElement struct { Name\tstring Text\tstring Request\t*Request Response\t*Response DOM\t*goquery.Selection Index\tint } HTMLElement 方法 Attr(k string)：返回当前元素的属性，上面示例中我们使用e.Attr(\u0026quot;href\u0026quot;)获取了href属性； ChildAttr(goquerySelector, attrName string)：返回goquerySelector选择的第一个子元素的attrName属性； ChildAttrs(goquerySelector, attrName string)：返回goquerySelector选择的所有子元素的attrName属性，以[]string返回； ChildText(goquerySelector string)：拼接goquerySelector选择的子元素的文本内容并返回； ChildTexts(goquerySelector string)：返回goquerySelector选择的子元素的文本内容组成的切片，以[]string返回。 ForEach(goquerySelector string, callback func(int, *HTMLElement))：对每个goquerySelector选择的子元素执行回调callback； Unmarshal(v interface{})：通过给结构体字段指定 goquerySelector 格式的 tag，可以将一个 HTMLElement 对象 Unmarshal 到一个结构体实例中。 colly 方法 NewCollector(options ...CollectorOption)：通过 options 可以设置是否异步（Async）、最大深度（Max-depth）等\nOnRequest(f RequestCallback)：请求建立时调用\nOnResponse(f ResponseCallback)：返回响应时调用\nOnHTML(goquerySelector string, f HTMLCallback)：选择器匹配 HTML 元素时调用\nOnXML(xpathQuery string, f XMLCallback)：xpath 匹配 XML 元素时调用\nOnError(f ErrorCallback)：在 HTTP 请求出错时调用\n百度小说热榜 各部分结构如下：\n每条热榜各自在一个 div.category-wrap_iQLoo 中； a 元素下 div.index_1Ew5p 是排名； 内容在 div.content_1YWBm 中； 内容中 a.title_dIF3B 是标题； 内容中两个 div.intro_1l0wp，前一个是作者，后一个是类型； 内容中 div.desc_3CTjT 是描述。 由此我们定义结构：\ntype Hot struct { Rank\tstring `selector:\u0026#34;a \u0026gt; div.index_1Ew5p\u0026#34;` Name\tstring `selector:\u0026#34;div.content_1YWBm \u0026gt; a.title_dIF3B\u0026#34;` Author string `selector:\u0026#34;div.content_1YWBm \u0026gt; div.intro_1l0wp:nth-child(2)\u0026#34;` Type\tstring `selector:\u0026#34;div.content_1YWBm \u0026gt; div.intro_1l0wp:nth-child(3)\u0026#34;` Desc\tstring `selector:\u0026#34;div.desc_3CTjT\u0026#34;` } tag 中是 CSS 选择器语法，添加这个是为了可以直接调用HTMLElement.Unmarshal()方法填充Hot对象。\n注册回调：\nc.OnHTML(\u0026#34;div.category-wrap_iQLoo\u0026#34;, func(e *colly.HTMLElement) { hot := \u0026amp;Hot{} err := e.Unmarshal(hot) if err != nil { fmt.Println(\u0026#34;error:\u0026#34;, err) return } hots = append(hots, hot) }) 起点不同分类畅销榜 首先定义结构：\ntype Novel struct { category\tstring\t// 分类 rank\tint\t// 排名 title string\t// 书名 author\tstring\t// 作者名 words float64\t// 字数/万 tags\t[]string\t// 标签 url string\t// 链接 lastUpdate\tstring\t// 上次更新时间 } 由于起点的分类、畅销榜单和书籍信息为三层，并且层与层之间的数据需要一一对应（例如玄幻小说畅销榜里的书都要对应到玄幻小说分类中）。所以使用三个 colly.Collector 对象嵌套\nfunc Crawl() { novels := make([]*Novel, 0, 100) c1 := colly.NewCollector( colly.AllowedDomains(\u0026#34;www.qidian.com\u0026#34;, \u0026#34;book.qidian.com\u0026#34;), colly.Async(true),\t// 异步请求 ) // 获取所有分类链接 c1.OnHTML(\u0026#34;#classify-list a\u0026#34;, func(e *colly.HTMLElement) { category := e.Attr(\u0026#34;title\u0026#34;) href := e.Attr(\u0026#34;href\u0026#34;) if href == \u0026#34;\u0026#34; { return } c2 := c1.Clone() // 获取榜单书籍链接 c2.OnHTML(\u0026#34;div.popular-serial + div li\u0026#34;, func(e *colly.HTMLElement) { rank, _ := strconv.Atoi(strings.TrimSpace(e.Attr(\u0026#34;data-rid\u0026#34;))) // 获取到的是相对链接，转换为 url infoUrl := e.Request.AbsoluteURL(e.ChildAttr(\u0026#34;a.link, a.name\u0026#34;, \u0026#34;href\u0026#34;)) c3 := c1.Clone() // 获取书籍详细信息 c3.OnHTML(\u0026#34;div.book-info\u0026#34;, func(e *colly.HTMLElement) { title := e.ChildText(\u0026#34;h1 em\u0026#34;) author := e.ChildText(\u0026#34;h1 a.writer\u0026#34;) // 截取 5 位以后的字符串作为时间 lastUpdate := string([]rune(e.ChildText(\u0026#34;h1 span.book-update-time\u0026#34;))[5:]) tags := make([]string, 0) tags = append(tags, e.ChildText(\u0026#34;p.tag \u0026gt; a:nth-child(4)\u0026#34;), e.ChildText(\u0026#34;p.tag \u0026gt; a:nth-child(5)\u0026#34;)) // 有些书有三个标签 if tag := e.ChildText(\u0026#34;p.tag \u0026gt; a:nth-child(6)\u0026#34;); tag != \u0026#34;\u0026#34; { tags = append(tags, tag) } words, _ := strconv.ParseFloat(e.ChildText(\u0026#34;p:nth-child(4) \u0026gt; em:nth-child(1)\u0026#34;), 64) novel := \u0026amp;Novel{ category:\tcategory, rank: rank, title:\ttitle, author: author, words:\twords, tags: tags, url:\tinfoUrl, lastUpdate: lastUpdate, } //fmt.Println(novel) novels = append(novels, novel) }) c3.Visit(infoUrl) }) c2.Visit(e.Request.AbsoluteURL(href)) // c2.Wait() // 因为是异步，所以需要等待完成 c3.Wait() }) c1.OnError(func(r *colly.Response, err error) { fmt.Println(\u0026#34;visiting \u0026#34;, r.Request.URL, \u0026#34;failed: \u0026#34;, err) }) c1.Visit(\u0026#34;https://www.qidian.com/\u0026#34;) c1.Wait() } 限速 有时候并发请求太多，网站会限制访问。这时就需要使用 LimitRule 了。说白了，LimitRule 就是限制访问速度和并发量的：\ntype LimitRule struct { DomainRegexp\tstring DomainGlob\tstring Delay time.Duration RandomDelay\ttime.Duration Parallelism\tint } 常用的就 Delay/RandomDelay/Parallism 这几个，分别表示请求与请求之间的延迟，随机延迟，和并发数。另外必须指定对哪些域名施行限制，通过 DomainRegexp 或 DomainGlob 设置，如果这两个字段都未设置 Limit() 方法会返回错误。用在上面的例子中：\nerr := c.Limit(\u0026amp;colly.LimitRule{ DomainRegexp: `unsplash\\.com`, RandomDelay:\t500 * time.Millisecond, Parallelism:\t12, }) if err != nil { log.Fatal(err) } 设置针对 unsplash.com 这个域名，请求与请求之间的随机最大延迟 500ms，最多同时并发 12 个请求。\n设置超时 有时候网速较慢，colly 中使用的 http.Client 有默认超时机制，我们可以通过colly.WithTransport() 选项改写：\nc.WithTransport(\u0026amp;http.Transport{ Proxy: http.ProxyFromEnvironment, DialContext: (\u0026amp;net.Dialer{ Timeout:\t30 * time.Second, KeepAlive: 30 * time.Second, }).DialContext, MaxIdleConns: 100, IdleConnTimeout:\t90 * time.Second, TLSHandshakeTimeout:\t10 * time.Second, ExpectContinueTimeout:\t1 * time.Second, }) 扩展 colly 在子包 extension 中提供了一些扩展特性，最最常用的就是随机 User-Agent 了。通常网站会通过 User-Agent 识别请求是否是浏览器发出的，爬虫一般会设置这个 Header 把自己伪装成浏览器。使用也比较简单：\nimport \u0026#34;github.com/gocolly/colly/v2/extensions\u0026#34; func main() { c := colly.NewCollector() extensions.RandomUserAgent(c) } 随机 User-Agent 实现也很简单，就是从一些预先定义好的 User-Agent 数组中随机一个设置到 Header 中：\nfunc RandomUserAgent(c *colly.Collector) { c.OnRequest(func(r *colly.Request) { r.Headers.Set(\u0026#34;User-Agent\u0026#34;, uaGens[rand.Intn(len(uaGens))]()) }) } 实现自己的扩展也不难，例如我们每次请求时需要设置一个特定的 Header，扩展可以这么写：\nfunc MyHeader(c *colly.Collector) { c.OnRequest(func(r *colly.Request) { r.Headers.Set(\u0026#34;My-Header\u0026#34;, \u0026#34;dj\u0026#34;) }) } 用 Collector 对象调用 MyHeader() 函数即可：\nMyHeader(c) 参考 Go 每日一库 GitHub Go 每日一库之 colly ","permalink":"https://note-site.pages.dev/posts/go/lib/colly/","summary":"\u003cp\u003e\u003ca href=\"https://github.com/gocolly/colly\"\u003e\u003ccode\u003ecolly\u003c/code\u003e\u003c/a\u003e 是用 Go 语言编写的功能强大的爬虫框架。它提供简洁的 API，拥有强劲的性能，可以自动处理 cookie\u0026amp;session，还有提供灵活的扩展机制。\u003c/p\u003e","title":"Colly"},{"content":"pie 封装了对切片和 map 的常用操作,能满足工作中的大部分需求。比如计算切片的交集、差集；对切片中元素按条件过滤的 Filter 函数；对切片中元素进行数据转换的 Each、Map 函数等。\npie v2 版本需要 Go 1.18+。Go1.17 及以下版本需要使用 v1 版本。\n使用示例 func TestPie(t *testing.T) { name := pie.Of([]string{\u0026#34;Bob\u0026#34;, \u0026#34;Sally\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Jane\u0026#34;}). FilterNot(func(name string) bool { return strings.HasPrefix(name, \u0026#34;J\u0026#34;) }). Map(strings.ToUpper). Last() fmt.Println(name) // \u0026#34;SALLY\u0026#34; } pie 包的目标 类型安全：无论是在 v1 版本还是 v2 版本的泛型中，都对类型做了限制，所以不会遇到运行时类型错误。 高性能：该库需要跟原生的 Go 实现一样快，否则该库封装就没有意义。 Nil 安全：该库的所有函数都能接收 nil 参数，并将其视为空切片，而不会引起 panic。 对原切片无副作用：所有的函数对传入的切片参数都不会做修改。 pie 包支持的功能 切片中的元素是否全部或任意一个满足指定的条件。\nAll 函数：判断切片中的元素是否都满足指定的条件。 Any 函数：判断切片中的元素只要有 1 个满足指定条件即可。 对切片元素进行排序功能。\nAreSorted 函数：判断切片是否是有序的 Sort 函数：对切片元素进行排序。 SortStableUsing 函数：使用指定的条件对切片进行排序，并且具有稳定性。 SortUsing 函数 对切片中的元素去重。\n判断切片中的元素是否不重复的 AreUnique 函数、去重函数 Unique 对切片进行前、后截取。\nBottom 函数：取切片后 n 个元素 Top 函数：取切片前 n 个元素 DropTop 函数：丢掉切片的前 n 个元素，并返回剩余的元素切片 两个或多个切片之间的集合运算\nDiff 函数：计算两个切片中的差集 Intersect 函数：计算两个或多个切片的交集 func TestDiff(t *testing.T) { added, removed := pie.Diff([]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}, []string{\u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;}) fmt.Println(added, removed) // [d] [a] } func TestIntersect(t *testing.T) { ss2 := pie.Intersect([]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}, []string{\u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;}) fmt.Println(ss2) // [c b] } 切片元素进行算数运算功能（只针对 Integer 和 float 类型的切片有效）。 Max 函数：返回切片中的最大元素 Min 函数：返回切片中的最小元素 Product 函数：对切片所有元素进行乘积运算 Sum 函数：对切片中所有元素进行求和运算 Average 函数：求所有元素的平均值 对切片中的元素进行数据转换功能：Each、Map、Filter、Flat、Reducer func TestEach(t *testing.T) { pie.Of([]string{\u0026#34;Bob\u0026#34;, \u0026#34;Sally\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Jane\u0026#34;}). Each(func(s string) { fmt.Println(s) }) } 针对 map 的操作： Keys 函数：获取 map 的所有键 Values 函数：获取 map 的所有值 ","permalink":"https://note-site.pages.dev/posts/go/lib/pie/","summary":"\u003cp\u003e\u003ca href=\"https://github.com/elliotchance/pie\"\u003epie\u003c/a\u003e 封装了\u003cstrong\u003e对切片和 map 的常用操作,能满足工作中的大部分需求\u003c/strong\u003e。比如计算切片的交集、差集；对切片中元素按条件过滤的 Filter 函数；对切片中元素进行数据转换的 Each、Map 函数等。\u003c/p\u003e","title":"Pie"},{"content":"singleflight 来源于准官方库 golang.org/x/sync/singleflight，能够抑制对下游的多次重复请求。主要提供了以下三个方法：\n// Do(): 相同的 key，fn 同时只会执行一次，返回执行的结果给 fn 执行期间，所有使用该 key 的调用 // v: fn 返回的数据 // err: fn 返回的err // shared: 表示返回数据是调用 fn 得到的还是其他相同 key 调用返回的 func (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) // DoChan(): 类似 Do() 方法，以 chan 返回结果 func (g *Group) DoChan(key string, fn func() (interface{}, error)) \u0026lt;-chan Result // Forget(): 失效 key，后续对此 key 的调用将执行 fn，而不是等待前面的调用完成 func (g *Group) Forget(key string) 使用方法 package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/sync/singleflight\u0026#34; \u0026#34;sync/atomic\u0026#34; \u0026#34;time\u0026#34; ) type Result string func find(ctx context.Context, query string) (Result, error) { return Result(fmt.Sprintf(\u0026#34;result for %q\u0026#34;, query)), nil } func main() { var g singleflight.Group const n = 5 waited := int32(n) done := make(chan struct{}) key := \u0026#34;https://weibo.com/1227368500/H3GIgngon\u0026#34; for i := 0; i \u0026lt; n; i++ { go func(j int) { v, _, shared := g.Do(key, func() (interface{}, error) { ret, err := find(context.Background(), key) return ret, err }) if atomic.AddInt32(\u0026amp;waited, -1) == 0 { close(done) } fmt.Printf(\u0026#34;index: %d, val: %v, shared: %v\\n\u0026#34;, j, v, shared) }(i) } select { case \u0026lt;-done: case \u0026lt;-time.After(time.Second): fmt.Println(\u0026#34;Do hangs\u0026#34;) } } 输出结果如下：\nindex: 1, val: result for \u0026#34;https://weibo.com/1227368500/H3GIgngon\u0026#34;, shared: true index: 2, val: result for \u0026#34;https://weibo.com/1227368500/H3GIgngon\u0026#34;, shared: true index: 4, val: result for \u0026#34;https://weibo.com/1227368500/H3GIgngon\u0026#34;, shared: true index: 3, val: result for \u0026#34;https://weibo.com/1227368500/H3GIgngon\u0026#34;, shared: true index: 0, val: result for \u0026#34;https://weibo.com/1227368500/H3GIgngon\u0026#34;, shared: true 注意事项 比较常见的业务场景是直接使用 singleflight.Do 方法，这在极端情况下可能会导致参与竞争的 goroutine 全部阻塞。例如从数据库读取数据并写入缓存中这个场景，如果 singleflight.Do 方法内部调用的函数因为某种原因阻塞住了，那么会导致所有等待缓存数据的 goroutine 全部阻塞。换言之，singleflight 是以牺牲成功率的代价控制了并发量。\n那么该如何解决以上问题呢？\n作为 Do() 的替代函数，singleflight 提供了 DoChan()。两者实现上完全一样，不同的是，DoChan() 通过 channel 返回结果，因此可以使用 select 语句实现超时控制。\nvar g singleflight.Group var wg sync.WaitGroup\t// 通过wg控制主进程在其它goroutine结束后再结束 const n = 5 key := \u0026#34;https://weibo.com/1227368500/H3GIgngon\u0026#34; for i := 0; i \u0026lt; n; i++ { go func(j int) { wg.Add(1) defer wg.Done() ch := g.DoChan(key, func() (interface{}, error) { ret, err := find(context.Background(), key) return ret, err }) timeout := time.After(500 * time.Millisecond) var ret singleflight.Result select { case ret = \u0026lt;-ch: fmt.Printf(\u0026#34;index: %d, val: %v, shared: %v\\n\u0026#34;, j, ret.Val, ret.Shared) case \u0026lt;-timeout: fmt.Printf(\u0026#34;%d: timeout\\n\u0026#34;, j) return } }(i) } wg.Wait() 输出结果与 Do 示例类似。\n在一些对可用性要求极高的场景下，往往需要一定的请求饱和度来保证业务的最终成功率。一次请求还是多次请求，对于下游服务而言并没有太大区别，此时使用 singleflight 只是为了降低请求的数量级，那么可以使用 Forget() 提高下游请求的并发：\nv, _, shared := g.Do(key, func() (interface{}, error) { go func() { time.Sleep(10 * time.Millisecond) fmt.Printf(\u0026#34;Deleting key: %v\\n\u0026#34;, key) g.Forget(key) }() ret, err := find(context.Background(), key) return ret, err }) 当有一个并发请求超过 10ms，那么将会有第二个请求发起，此时只有 10ms 内的请求最多发起一次请求，即最大并发：100 QPS。单次请求失败的影响大大降低。\n当然，如果单次的失败无法容忍，在高并发的场景下更好的处理方案是：\n放弃使用同步请求，牺牲数据更新的实时性 “缓存” 存储准实时的数据 + “异步更新” 数据到缓存 内部实现 见 singleflight内部实现\n参考 sync.singleflight 到底怎么用才对？\n","permalink":"https://note-site.pages.dev/posts/go/lib/singleflight/","summary":"\u003cp\u003e\u003ccode\u003esingleflight\u003c/code\u003e 来源于准官方库 \u003ccode\u003egolang.org/x/sync/singleflight\u003c/code\u003e，能够抑制对下游的多次重复请求。主要提供了以下三个方法：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// Do():  相同的 key，fn 同时只会执行一次，返回执行的结果给 fn 执行期间，所有使用该 key 的调用\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// v: fn 返回的数据\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// err: fn 返回的err\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// shared: 表示返回数据是调用 fn 得到的还是其他相同 key 调用返回的\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eg\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eGroup\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nf\"\u003eDo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ekey\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003efn\u003c/span\u003e \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kd\"\u003einterface\u003c/span\u003e\u003cspan class=\"p\"\u003e{},\u003c/span\u003e \u003cspan class=\"kt\"\u003eerror\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ev\u003c/span\u003e \u003cspan class=\"kd\"\u003einterface\u003c/span\u003e\u003cspan class=\"p\"\u003e{},\u003c/span\u003e \u003cspan class=\"nx\"\u003eerr\u003c/span\u003e \u003cspan class=\"kt\"\u003eerror\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eshared\u003c/span\u003e \u003cspan class=\"kt\"\u003ebool\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// DoChan(): 类似 Do() 方法，以 chan 返回结果\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eg\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eGroup\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nf\"\u003eDoChan\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ekey\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003efn\u003c/span\u003e \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kd\"\u003einterface\u003c/span\u003e\u003cspan class=\"p\"\u003e{},\u003c/span\u003e \u003cspan class=\"kt\"\u003eerror\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;-\u003c/span\u003e\u003cspan class=\"kd\"\u003echan\u003c/span\u003e \u003cspan class=\"nx\"\u003eResult\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// Forget(): 失效 key，后续对此 key 的调用将执行 fn，而不是等待前面的调用完成\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eg\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nx\"\u003eGroup\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"nf\"\u003eForget\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ekey\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"使用方法\"\u003e使用方法\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003epackage\u003c/span\u003e \u003cspan class=\"nx\"\u003emain\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"s\"\u003e\u0026#34;context\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"s\"\u003e\u0026#34;fmt\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"s\"\u003e\u0026#34;golang.org/x/sync/singleflight\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"s\"\u003e\u0026#34;sync/atomic\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"s\"\u003e\u0026#34;time\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003etype\u003c/span\u003e \u003cspan class=\"nx\"\u003eResult\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003efind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ectx\u003c/span\u003e \u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eContext\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003equery\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eResult\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eerror\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nf\"\u003eResult\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eSprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;result for %q\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003equery\u003c/span\u003e\u003cspan class=\"p\"\u003e)),\u003c/span\u003e \u003cspan class=\"kc\"\u003enil\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003efunc\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kd\"\u003evar\u003c/span\u003e \u003cspan class=\"nx\"\u003eg\u003c/span\u003e \u003cspan class=\"nx\"\u003esingleflight\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eGroup\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"kd\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003en\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003ewaited\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nb\"\u003eint32\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003edone\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nb\"\u003emake\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kd\"\u003echan\u003c/span\u003e \u003cspan class=\"kd\"\u003estruct\u003c/span\u003e\u003cspan class=\"p\"\u003e{})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"nx\"\u003ekey\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;https://weibo.com/1227368500/H3GIgngon\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"nx\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"k\"\u003ego\u003c/span\u003e \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ej\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nx\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003e_\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eshared\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nx\"\u003eg\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eDo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kd\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kd\"\u003einterface\u003c/span\u003e\u003cspan class=\"p\"\u003e{},\u003c/span\u003e \u003cspan class=\"kt\"\u003eerror\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"nx\"\u003eret\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eerr\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"nf\"\u003efind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eBackground\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"nx\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003eret\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eerr\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"p\"\u003e})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nx\"\u003eatomic\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eAddInt32\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"nx\"\u003ewaited\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\t\u003cspan class=\"nb\"\u003eclose\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003edone\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\t\u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;index: %d, val: %v, shared: %v\\n\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nx\"\u003eshared\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"p\"\u003e}(\u003c/span\u003e\u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003eselect\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;-\u003c/span\u003e\u003cspan class=\"nx\"\u003edone\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;-\u003c/span\u003e\u003cspan class=\"nx\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eAfter\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eSecond\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\t\u003cspan class=\"nx\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003ePrintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Do hangs\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e输出结果如下：\u003c/p\u003e","title":"Singleflight"}]
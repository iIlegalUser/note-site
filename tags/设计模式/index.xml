<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>设计模式 on Note</title>
    <link>https://note-site.pages.dev/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on Note</description>
    <image>
      <title>Note</title>
      <url>https://note-site.pages.dev/opengraph.webp</url>
      <link>https://note-site.pages.dev/opengraph.webp</link>
    </image>
    <generator>Hugo -- 0.147.2</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 02 Aug 2023 23:47:17 +0800</lastBuildDate>
    <atom:link href="https://note-site.pages.dev/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>解释器模式</title>
      <link>https://note-site.pages.dev/posts/design-pattern/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 02 Aug 2023 23:47:17 +0800</pubDate>
      <guid>https://note-site.pages.dev/posts/design-pattern/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Interpreter Pattern: Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.&lt;/p&gt;
&lt;p&gt;解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。&lt;/p&gt;</description>
    </item>
    <item>
      <title>命令模式</title>
      <link>https://note-site.pages.dev/posts/design-pattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 09 May 2023 12:28:53 +0800</pubDate>
      <guid>https://note-site.pages.dev/posts/design-pattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Command Pattern: Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.&lt;/p&gt;
&lt;p&gt;命令模式：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>职责链模式</title>
      <link>https://note-site.pages.dev/posts/design-pattern/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 08 May 2023 16:38:38 +0800</pubDate>
      <guid>https://note-site.pages.dev/posts/design-pattern/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，将请求的发送者和请求的处理者解耦。这就是职责链模式的模式动机。&lt;/p&gt;</description>
    </item>
    <item>
      <title>代理模式</title>
      <link>https://note-site.pages.dev/posts/design-pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 07 May 2023 17:59:23 +0800</pubDate>
      <guid>https://note-site.pages.dev/posts/design-pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Proxy Pattern: Provide a surrogate or placeholder for another object to control access to it.&lt;/p&gt;
&lt;p&gt;代理模式：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。&lt;/p&gt;</description>
    </item>
    <item>
      <title>享元模式</title>
      <link>https://note-site.pages.dev/posts/design-pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 06 May 2023 15:14:55 +0800</pubDate>
      <guid>https://note-site.pages.dev/posts/design-pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;Java 中字符串的使用非常普遍，如果每个字符串都用一个对象来表示，会导致系统中有很多重复的字符串，占用较多的内存空间。那么如何避免系统中出现大量相同或相似的对象，同时又不影响客户端程序这些对象进行操作？享元模式正是为解决这一类问题而诞生。享元模式通过共享技术实现相同或相似对象的重用，在逻辑上每一个出现的字符都有一个对象与之对应，然而在物理上它们却共享同一个享元对象，这个对象可以出现在一个字符串的不同地方，相同的字符对象都指向同一个实例，在享元模式中存储这些共享实例对象的地方称为享元池 (Flyweight Pool) 。&lt;/p&gt;</description>
    </item>
    <item>
      <title>外观模式</title>
      <link>https://note-site.pages.dev/posts/design-pattern/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 05 May 2023 13:44:43 +0800</pubDate>
      <guid>https://note-site.pages.dev/posts/design-pattern/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Facade Pattern: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.&lt;/p&gt;
&lt;p&gt;外观模式：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口， 这个接口使得这一子系统更加容易使用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>装饰模式</title>
      <link>https://note-site.pages.dev/posts/design-pattern/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 04 May 2023 20:30:18 +0800</pubDate>
      <guid>https://note-site.pages.dev/posts/design-pattern/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Decorator Pattern: Attach additional resposibilies to an object dynamically. Decorators provide a flexible alternative to subclassing for exlending functionality.&lt;/p&gt;
&lt;p&gt;装饰模式：动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。&lt;/p&gt;</description>
    </item>
    <item>
      <title>组合模式</title>
      <link>https://note-site.pages.dev/posts/design-pattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 21:17:06 +0800</pubDate>
      <guid>https://note-site.pages.dev/posts/design-pattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Composite Pattern: Compose object into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.&lt;/p&gt;
&lt;p&gt;组合模式：组合多个对象形成树形结构以表示具有部分－整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。&lt;/p&gt;</description>
    </item>
    <item>
      <title>桥接模式</title>
      <link>https://note-site.pages.dev/posts/design-pattern/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 03 May 2023 12:01:20 +0800</pubDate>
      <guid>https://note-site.pages.dev/posts/design-pattern/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Bridge Pattern: Decouple an abstraction from its implementation so that the two can vary independently.&lt;/p&gt;
&lt;p&gt;桥接模式：将抽象部分与它的实现部分解耦，使得两者都能够独立变化。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;桥接模式是一种结构型设计模式，它将抽象与实现解耦，使得两者可以独立地变化。这种模式涉及到一个抽象类，它将实现类的对象作为一个成员变量，并通过构造函数或者 setter 方法将实现类的对象传递给抽象类。这样，抽象类可以在运行时调用实现类的方法，而不需要知道具体的实现细节。&lt;/p&gt;</description>
    </item>
    <item>
      <title>单例模式</title>
      <link>https://note-site.pages.dev/posts/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 02 May 2023 00:19:42 +0800</pubDate>
      <guid>https://note-site.pages.dev/posts/design-pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Singleton Pattern: Ensure a class has only one instance, and provide a global point of access to it.&lt;/p&gt;
&lt;p&gt;单例模式：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;优缺点和使用场景&#34;&gt;优缺点和使用场景&lt;/h2&gt;
&lt;p&gt;单例模式的优点主要如下：&lt;/p&gt;
&lt;p&gt;（1）单例模式提供了对唯一实例的受控访问。 因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。&lt;/p&gt;</description>
    </item>
    <item>
      <title>原型模式</title>
      <link>https://note-site.pages.dev/posts/design-pattern/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 May 2023 00:19:00 +0800</pubDate>
      <guid>https://note-site.pages.dev/posts/design-pattern/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Prototype Pattern: Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.&lt;/p&gt;
&lt;p&gt;原型模式：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;原型模式是一种创建型设计模式，它允许使用者通过复制现有对象来创建新的对象。这种模式既可以避免直接创建对象开销大，又可以提高系统性能。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>